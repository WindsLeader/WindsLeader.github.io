<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
  @charset "UTF-8";button[data-v-fd53aff6]{border:1px #fff solid;outline:none;color:#fff}svg[data-v-fd53aff6]{height:25px}#play_window[data-v-fd53aff6]{display:flex;justify-content:space-around;padding:5vh 0}#play_window #preview[data-v-fd53aff6],#play_window>#block_box[data-v-fd53aff6]{display:flex;flex-direction:column}#play_window #preview>.block_line[data-v-fd53aff6],#play_window>#block_box>.block_line[data-v-fd53aff6]{display:flex;justify-content:center}#play_window #preview .block[data-v-fd53aff6],#play_window>#block_box .block[data-v-fd53aff6]{border:1px #fff solid}#play_window>#fun_area[data-v-fd53aff6]{display:flex;flex-direction:column;justify-content:space-between;align-items:center}#play_window>#fun_area #score[data-v-fd53aff6],#play_window>#fun_area #max_score[data-v-fd53aff6]{text-align:center;font-size:25px;font-weight:900}#play_window>#fun_area>#score_box>#score_out[data-v-fd53aff6]{margin-bottom:40px}#play_window>#fun_area>#score_box>#score_out>#score[data-v-fd53aff6]{padding-top:25px}#play_window>#fun_area>#score_box>#score_out>#score[data-v-fd53aff6]:before{content:"分数";color:#ff514d}#play_window>#fun_area>#score_box>#max_score_out>#max_score[data-v-fd53aff6]{padding-top:25px}#play_window>#fun_area>#score_box>#max_score_out>#max_score[data-v-fd53aff6]:before{content:"最高分数";color:#ffa700}#play_window>#fun_area>#btns_out>#btns[data-v-fd53aff6]{display:grid;grid-template-columns:repeat(3,1fr)}#play_window>#fun_area>#btns_out>#btns>button[data-v-fd53aff6]{height:60px;display:flex;align-items:center;justify-content:center;margin:5px;font-size:16px;font-weight:900}#play_window>#fun_area>#btns_out>#btns>button>.dir_logo[data-v-fd53aff6]{width:20px}#play_window>#fun_area>#btns_out>#btns>.direction[data-v-fd53aff6]{background-color:#34b7fd}#play_window>#fun_area>#btns_out>#btns>.role[data-v-fd53aff6]{background-color:#1acd72}#play_window>#fun_area>#btns_out>#btns>#space[data-v-fd53aff6]{grid-column-start:span 3}#play_window>#fun_area>#btns_out>#btns>button[data-v-fd53aff6]:hover{background-color:#ffd601}#play_window>#play_info[data-v-fd53aff6]{display:flex;flex-direction:column;justify-content:space-between}#play_window>#play_info>#setting_out>#setting[data-v-fd53aff6]{display:grid;grid-template-columns:repeat(3,1fr);color:#888}#play_window>#play_info>#setting_out>#setting>label>input[type=checkbox][data-v-fd53aff6]{display:none}#play_window>#play_info>#setting_out>#setting>label>div[data-v-fd53aff6],#play_window>#play_info>#setting_out>#setting>label>a[data-v-fd53aff6]{display:flex;flex-direction:column;align-items:center;justify-content:space-evenly;margin:5px;font-size:12px;height:70px}#play_window>#play_info>#setting_out>#setting>label>a[data-v-fd53aff6]:hover,#play_window>#play_info>#setting_out>#setting>label>div[data-v-fd53aff6]:hover,#play_window>#play_info>#setting_out>#setting>label>button[data-v-fd53aff6]:hover{background-color:#5fc61d;color:#fff}#play_window>#play_info>#setting_out>#setting>label>input[type=checkbox]:checked~div[data-v-fd53aff6]{color:#5fc61d}#play_window>#play_info>#setting_out>#setting>label>input[type=checkbox]:hover~div[data-v-fd53aff6]{background-color:#5fc61d;color:#fff}#play_window>#play_info>#setting_out>#setting>label>#board_size[data-v-fd53aff6]{color:#ffa700}#play_window>#play_info>#setting_out>#setting>label>#board_size[data-v-fd53aff6]:hover{background-color:#ffa700;color:#fff}#play_window>#play_info>#setting_out>#setting>label>#github_link[data-v-fd53aff6]:hover{background-color:#000}.out[data-v-fd53aff6]{position:relative;width:300px}.out>div[data-v-fd53aff6]{border:5px dashed #ddd;padding:5px}.out>div[data-v-fd53aff6]:before{position:absolute;top:-32px;left:14px;font-size:30px;font-weight:900;background-color:#fff;padding:10px 12px}*{box-sizing:border-box;padding:0;margin:0;-webkit-user-select:none;user-select:none}
  </style>
  <title>俄罗斯方块</title>
</head>

<body>
  <div id="app"></div>

  <script>
    (function () { const t = document.createElement("link").relList; if (t && t.supports && t.supports("modulepreload")) return; for (const r of document.querySelectorAll('link[rel="modulepreload"]')) s(r); new MutationObserver(r => { for (const o of r) if (o.type === "childList") for (const l of o.addedNodes) l.tagName === "LINK" && l.rel === "modulepreload" && s(l) }).observe(document, { childList: !0, subtree: !0 }); function n(r) { const o = {}; return r.integrity && (o.integrity = r.integrity), r.referrerPolicy && (o.referrerPolicy = r.referrerPolicy), r.crossOrigin === "use-credentials" ? o.credentials = "include" : r.crossOrigin === "anonymous" ? o.credentials = "omit" : o.credentials = "same-origin", o } function s(r) { if (r.ep) return; r.ep = !0; const o = n(r); fetch(r.href, o) } })(); function Nn(e, t) { const n = Object.create(null), s = e.split(","); for (let r = 0; r < s.length; r++)n[s[r]] = !0; return t ? r => !!n[r.toLowerCase()] : r => !!n[r] } const J = {}, lt = [], ye = () => { }, Rr = () => !1, Fr = /^on[^a-z]/, en = e => Fr.test(e), Ln = e => e.startsWith("onUpdate:"), se = Object.assign, Bn = (e, t) => { const n = e.indexOf(t); n > -1 && e.splice(n, 1) }, Nr = Object.prototype.hasOwnProperty, H = (e, t) => Nr.call(e, t), $ = Array.isArray, it = e => tn(e) === "[object Map]", Hs = e => tn(e) === "[object Set]", N = e => typeof e == "function", te = e => typeof e == "string", Hn = e => typeof e == "symbol", Z = e => e !== null && typeof e == "object", js = e => Z(e) && N(e.then) && N(e.catch), Ds = Object.prototype.toString, tn = e => Ds.call(e), Lr = e => tn(e).slice(8, -1), Ss = e => tn(e) === "[object Object]", jn = e => te(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e, zt = Nn(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"), nn = e => { const t = Object.create(null); return n => t[n] || (t[n] = e(n)) }, Br = /-(\w)/g, ut = nn(e => e.replace(Br, (t, n) => n ? n.toUpperCase() : "")), Hr = /\B([A-Z])/g, pt = nn(e => e.replace(Hr, "-$1").toLowerCase()), ks = nn(e => e.charAt(0).toUpperCase() + e.slice(1)), hn = nn(e => e ? `on${ks(e)}` : ""), Ct = (e, t) => !Object.is(e, t), pn = (e, t) => { for (let n = 0; n < e.length; n++)e[n](t) }, Zt = (e, t, n) => { Object.defineProperty(e, t, { configurable: !0, enumerable: !1, value: n }) }, jr = e => { const t = parseFloat(e); return isNaN(t) ? e : t }; let os; const yn = () => os || (os = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {}); function Ot(e) { if ($(e)) { const t = {}; for (let n = 0; n < e.length; n++) { const s = e[n], r = te(s) ? Ur(s) : Ot(s); if (r) for (const o in r) t[o] = r[o] } return t } else { if (te(e)) return e; if (Z(e)) return e } } const Dr = /;(?![^(]*\))/g, Sr = /:([^]+)/, kr = /\/\*[^]*?\*\//g; function Ur(e) { const t = {}; return e.replace(kr, "").split(Dr).forEach(n => { if (n) { const s = n.split(Sr); s.length > 1 && (t[s[0].trim()] = s[1].trim()) } }), t } function Dn(e) { let t = ""; if (te(e)) t = e; else if ($(e)) for (let n = 0; n < e.length; n++) { const s = Dn(e[n]); s && (t += s + " ") } else if (Z(e)) for (const n in e) e[n] && (t += n + " "); return t.trim() } const Kr = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", Wr = Nn(Kr); function Us(e) { return !!e || e === "" } const Bt = e => te(e) ? e : e == null ? "" : $(e) || Z(e) && (e.toString === Ds || !N(e.toString)) ? JSON.stringify(e, Ks, 2) : String(e), Ks = (e, t) => t && t.__v_isRef ? Ks(e, t.value) : it(t) ? { [`Map(${t.size})`]: [...t.entries()].reduce((n, [s, r]) => (n[`${s} =>`] = r, n), {}) } : Hs(t) ? { [`Set(${t.size})`]: [...t.values()] } : Z(t) && !$(t) && !Ss(t) ? String(t) : t; let be; class zr { constructor(t = !1) { this.detached = t, this._active = !0, this.effects = [], this.cleanups = [], this.parent = be, !t && be && (this.index = (be.scopes || (be.scopes = [])).push(this) - 1) } get active() { return this._active } run(t) { if (this._active) { const n = be; try { return be = this, t() } finally { be = n } } } on() { be = this } off() { be = this.parent } stop(t) { if (this._active) { let n, s; for (n = 0, s = this.effects.length; n < s; n++)this.effects[n].stop(); for (n = 0, s = this.cleanups.length; n < s; n++)this.cleanups[n](); if (this.scopes) for (n = 0, s = this.scopes.length; n < s; n++)this.scopes[n].stop(!0); if (!this.detached && this.parent && !t) { const r = this.parent.scopes.pop(); r && r !== this && (this.parent.scopes[this.index] = r, r.index = this.index) } this.parent = void 0, this._active = !1 } } } function qr(e, t = be) { t && t.active && t.effects.push(e) } function Jr() { return be } const Sn = e => { const t = new Set(e); return t.w = 0, t.n = 0, t }, Ws = e => (e.w & We) > 0, zs = e => (e.n & We) > 0, Vr = ({ deps: e }) => { if (e.length) for (let t = 0; t < e.length; t++)e[t].w |= We }, Zr = e => { const { deps: t } = e; if (t.length) { let n = 0; for (let s = 0; s < t.length; s++) { const r = t[s]; Ws(r) && !zs(r) ? r.delete(e) : t[n++] = r, r.w &= ~We, r.n &= ~We } t.length = n } }, En = new WeakMap; let xt = 0, We = 1; const Cn = 30; let xe; const Ye = Symbol(""), On = Symbol(""); class kn { constructor(t, n = null, s) { this.fn = t, this.scheduler = n, this.active = !0, this.deps = [], this.parent = void 0, qr(this, s) } run() { if (!this.active) return this.fn(); let t = xe, n = Ue; for (; t;) { if (t === this) return; t = t.parent } try { return this.parent = xe, xe = this, Ue = !0, We = 1 << ++xt, xt <= Cn ? Vr(this) : ls(this), this.fn() } finally { xt <= Cn && Zr(this), We = 1 << --xt, xe = this.parent, Ue = n, this.parent = void 0, this.deferStop && this.stop() } } stop() { xe === this ? this.deferStop = !0 : this.active && (ls(this), this.onStop && this.onStop(), this.active = !1) } } function ls(e) { const { deps: t } = e; if (t.length) { for (let n = 0; n < t.length; n++)t[n].delete(e); t.length = 0 } } let Ue = !0; const qs = []; function _t() { qs.push(Ue), Ue = !1 } function gt() { const e = qs.pop(); Ue = e === void 0 ? !0 : e } function he(e, t, n) { if (Ue && xe) { let s = En.get(e); s || En.set(e, s = new Map); let r = s.get(n); r || s.set(n, r = Sn()), Js(r) } } function Js(e, t) { let n = !1; xt <= Cn ? zs(e) || (e.n |= We, n = !Ws(e)) : n = !e.has(xe), n && (e.add(xe), xe.deps.push(e)) } function Fe(e, t, n, s, r, o) { const l = En.get(e); if (!l) return; let c = []; if (t === "clear") c = [...l.values()]; else if (n === "length" && $(e)) { const u = Number(s); l.forEach((a, _) => { (_ === "length" || _ >= u) && c.push(a) }) } else switch (n !== void 0 && c.push(l.get(n)), t) { case "add": $(e) ? jn(n) && c.push(l.get("length")) : (c.push(l.get(Ye)), it(e) && c.push(l.get(On))); break; case "delete": $(e) || (c.push(l.get(Ye)), it(e) && c.push(l.get(On))); break; case "set": it(e) && c.push(l.get(Ye)); break }if (c.length === 1) c[0] && Tn(c[0]); else { const u = []; for (const a of c) a && u.push(...a); Tn(Sn(u)) } } function Tn(e, t) { const n = $(e) ? e : [...e]; for (const s of n) s.computed && is(s); for (const s of n) s.computed || is(s) } function is(e, t) { (e !== xe || e.allowRecurse) && (e.scheduler ? e.scheduler() : e.run()) } const Qr = Nn("__proto__,__v_isRef,__isVue"), Vs = new Set(Object.getOwnPropertyNames(Symbol).filter(e => e !== "arguments" && e !== "caller").map(e => Symbol[e]).filter(Hn)), Yr = Un(), Xr = Un(!1, !0), Gr = Un(!0), cs = eo(); function eo() { const e = {}; return ["includes", "indexOf", "lastIndexOf"].forEach(t => { e[t] = function (...n) { const s = D(this); for (let o = 0, l = this.length; o < l; o++)he(s, "get", o + ""); const r = s[t](...n); return r === -1 || r === !1 ? s[t](...n.map(D)) : r } }), ["push", "pop", "shift", "unshift", "splice"].forEach(t => { e[t] = function (...n) { _t(); const s = D(this)[t].apply(this, n); return gt(), s } }), e } function to(e) { const t = D(this); return he(t, "has", e), t.hasOwnProperty(e) } function Un(e = !1, t = !1) { return function (s, r, o) { if (r === "__v_isReactive") return !e; if (r === "__v_isReadonly") return e; if (r === "__v_isShallow") return t; if (r === "__v_raw" && o === (e ? t ? vo : Gs : t ? Xs : Ys).get(s)) return s; const l = $(s); if (!e) { if (l && H(cs, r)) return Reflect.get(cs, r, o); if (r === "hasOwnProperty") return to } const c = Reflect.get(s, r, o); return (Hn(r) ? Vs.has(r) : Qr(r)) || (e || he(s, "get", r), t) ? c : fe(c) ? l && jn(r) ? c : c.value : Z(c) ? e ? er(c) : zn(c) : c } } const no = Zs(), so = Zs(!0); function Zs(e = !1) { return function (n, s, r, o) { let l = n[s]; if (at(l) && fe(l) && !fe(r)) return !1; if (!e && (!Qt(r) && !at(r) && (l = D(l), r = D(r)), !$(n) && fe(l) && !fe(r))) return l.value = r, !0; const c = $(n) && jn(s) ? Number(s) < n.length : H(n, s), u = Reflect.set(n, s, r, o); return n === D(o) && (c ? Ct(r, l) && Fe(n, "set", s, r) : Fe(n, "add", s, r)), u } } function ro(e, t) { const n = H(e, t); e[t]; const s = Reflect.deleteProperty(e, t); return s && n && Fe(e, "delete", t, void 0), s } function oo(e, t) { const n = Reflect.has(e, t); return (!Hn(t) || !Vs.has(t)) && he(e, "has", t), n } function lo(e) { return he(e, "iterate", $(e) ? "length" : Ye), Reflect.ownKeys(e) } const Qs = { get: Yr, set: no, deleteProperty: ro, has: oo, ownKeys: lo }, io = { get: Gr, set(e, t) { return !0 }, deleteProperty(e, t) { return !0 } }, co = se({}, Qs, { get: Xr, set: so }), Kn = e => e, sn = e => Reflect.getPrototypeOf(e); function Ht(e, t, n = !1, s = !1) { e = e.__v_raw; const r = D(e), o = D(t); n || (t !== o && he(r, "get", t), he(r, "get", o)); const { has: l } = sn(r), c = s ? Kn : n ? Jn : Tt; if (l.call(r, t)) return c(e.get(t)); if (l.call(r, o)) return c(e.get(o)); e !== r && e.get(t) } function jt(e, t = !1) { const n = this.__v_raw, s = D(n), r = D(e); return t || (e !== r && he(s, "has", e), he(s, "has", r)), e === r ? n.has(e) : n.has(e) || n.has(r) } function Dt(e, t = !1) { return e = e.__v_raw, !t && he(D(e), "iterate", Ye), Reflect.get(e, "size", e) } function fs(e) { e = D(e); const t = D(this); return sn(t).has.call(t, e) || (t.add(e), Fe(t, "add", e, e)), this } function us(e, t) { t = D(t); const n = D(this), { has: s, get: r } = sn(n); let o = s.call(n, e); o || (e = D(e), o = s.call(n, e)); const l = r.call(n, e); return n.set(e, t), o ? Ct(t, l) && Fe(n, "set", e, t) : Fe(n, "add", e, t), this } function as(e) { const t = D(this), { has: n, get: s } = sn(t); let r = n.call(t, e); r || (e = D(e), r = n.call(t, e)), s && s.call(t, e); const o = t.delete(e); return r && Fe(t, "delete", e, void 0), o } function ds() { const e = D(this), t = e.size !== 0, n = e.clear(); return t && Fe(e, "clear", void 0, void 0), n } function St(e, t) { return function (s, r) { const o = this, l = o.__v_raw, c = D(l), u = t ? Kn : e ? Jn : Tt; return !e && he(c, "iterate", Ye), l.forEach((a, _) => s.call(r, u(a), u(_), o)) } } function kt(e, t, n) { return function (...s) { const r = this.__v_raw, o = D(r), l = it(o), c = e === "entries" || e === Symbol.iterator && l, u = e === "keys" && l, a = r[e](...s), _ = n ? Kn : t ? Jn : Tt; return !t && he(o, "iterate", u ? On : Ye), { next() { const { value: b, done: C } = a.next(); return C ? { value: b, done: C } : { value: c ? [_(b[0]), _(b[1])] : _(b), done: C } }, [Symbol.iterator]() { return this } } } } function De(e) { return function (...t) { return e === "delete" ? !1 : this } } function fo() { const e = { get(o) { return Ht(this, o) }, get size() { return Dt(this) }, has: jt, add: fs, set: us, delete: as, clear: ds, forEach: St(!1, !1) }, t = { get(o) { return Ht(this, o, !1, !0) }, get size() { return Dt(this) }, has: jt, add: fs, set: us, delete: as, clear: ds, forEach: St(!1, !0) }, n = { get(o) { return Ht(this, o, !0) }, get size() { return Dt(this, !0) }, has(o) { return jt.call(this, o, !0) }, add: De("add"), set: De("set"), delete: De("delete"), clear: De("clear"), forEach: St(!0, !1) }, s = { get(o) { return Ht(this, o, !0, !0) }, get size() { return Dt(this, !0) }, has(o) { return jt.call(this, o, !0) }, add: De("add"), set: De("set"), delete: De("delete"), clear: De("clear"), forEach: St(!0, !0) }; return ["keys", "values", "entries", Symbol.iterator].forEach(o => { e[o] = kt(o, !1, !1), n[o] = kt(o, !0, !1), t[o] = kt(o, !1, !0), s[o] = kt(o, !0, !0) }), [e, n, t, s] } const [uo, ao, ho, po] = fo(); function Wn(e, t) { const n = t ? e ? po : ho : e ? ao : uo; return (s, r, o) => r === "__v_isReactive" ? !e : r === "__v_isReadonly" ? e : r === "__v_raw" ? s : Reflect.get(H(n, r) && r in s ? n : s, r, o) } const _o = { get: Wn(!1, !1) }, go = { get: Wn(!1, !0) }, mo = { get: Wn(!0, !1) }, Ys = new WeakMap, Xs = new WeakMap, Gs = new WeakMap, vo = new WeakMap; function bo(e) { switch (e) { case "Object": case "Array": return 1; case "Map": case "Set": case "WeakMap": case "WeakSet": return 2; default: return 0 } } function xo(e) { return e.__v_skip || !Object.isExtensible(e) ? 0 : bo(Lr(e)) } function zn(e) { return at(e) ? e : qn(e, !1, Qs, _o, Ys) } function wo(e) { return qn(e, !1, co, go, Xs) } function er(e) { return qn(e, !0, io, mo, Gs) } function qn(e, t, n, s, r) { if (!Z(e) || e.__v_raw && !(t && e.__v_isReactive)) return e; const o = r.get(e); if (o) return o; const l = xo(e); if (l === 0) return e; const c = new Proxy(e, l === 2 ? s : n); return r.set(e, c), c } function ct(e) { return at(e) ? ct(e.__v_raw) : !!(e && e.__v_isReactive) } function at(e) { return !!(e && e.__v_isReadonly) } function Qt(e) { return !!(e && e.__v_isShallow) } function tr(e) { return ct(e) || at(e) } function D(e) { const t = e && e.__v_raw; return t ? D(t) : e } function nr(e) { return Zt(e, "__v_skip", !0), e } const Tt = e => Z(e) ? zn(e) : e, Jn = e => Z(e) ? er(e) : e; function sr(e) { Ue && xe && (e = D(e), Js(e.dep || (e.dep = Sn()))) } function rr(e, t) { e = D(e); const n = e.dep; n && Tn(n) } function fe(e) { return !!(e && e.__v_isRef === !0) } function qe(e) { return yo(e, !1) } function yo(e, t) { return fe(e) ? e : new Eo(e, t) } class Eo { constructor(t, n) { this.__v_isShallow = n, this.dep = void 0, this.__v_isRef = !0, this._rawValue = n ? t : D(t), this._value = n ? t : Tt(t) } get value() { return sr(this), this._value } set value(t) { const n = this.__v_isShallow || Qt(t) || at(t); t = n ? t : D(t), Ct(t, this._rawValue) && (this._rawValue = t, this._value = n ? t : Tt(t), rr(this)) } } function q(e) { return fe(e) ? e.value : e } const Co = { get: (e, t, n) => q(Reflect.get(e, t, n)), set: (e, t, n, s) => { const r = e[t]; return fe(r) && !fe(n) ? (r.value = n, !0) : Reflect.set(e, t, n, s) } }; function or(e) { return ct(e) ? e : new Proxy(e, Co) } class Oo { constructor(t, n, s, r) { this._setter = n, this.dep = void 0, this.__v_isRef = !0, this.__v_isReadonly = !1, this._dirty = !0, this.effect = new kn(t, () => { this._dirty || (this._dirty = !0, rr(this)) }), this.effect.computed = this, this.effect.active = this._cacheable = !r, this.__v_isReadonly = s } get value() { const t = D(this); return sr(t), (t._dirty || !t._cacheable) && (t._dirty = !1, t._value = t.effect.run()), t._value } set value(t) { this._setter(t) } } function To(e, t, n = !1) { let s, r; const o = N(e); return o ? (s = e, r = ye) : (s = e.get, r = e.set), new Oo(s, r, o || !r, n) } function Ke(e, t, n, s) { let r; try { r = s ? e(...s) : e() } catch (o) { rn(o, t, n) } return r } function Ee(e, t, n, s) { if (N(e)) { const o = Ke(e, t, n, s); return o && js(o) && o.catch(l => { rn(l, t, n) }), o } const r = []; for (let o = 0; o < e.length; o++)r.push(Ee(e[o], t, n, s)); return r } function rn(e, t, n, s = !0) { const r = t ? t.vnode : null; if (t) { let o = t.parent; const l = t.proxy, c = n; for (; o;) { const a = o.ec; if (a) { for (let _ = 0; _ < a.length; _++)if (a[_](e, l, c) === !1) return } o = o.parent } const u = t.appContext.config.errorHandler; if (u) { Ke(u, null, 10, [e, l, c]); return } } Io(e, n, r, s) } function Io(e, t, n, s = !0) { console.error(e) } let It = !1, In = !1; const ie = []; let Ae = 0; const ft = []; let Re = null, Ze = 0; const lr = Promise.resolve(); let Vn = null; function Ao(e) { const t = Vn || lr; return e ? t.then(this ? e.bind(this) : e) : t } function Mo(e) { let t = Ae + 1, n = ie.length; for (; t < n;) { const s = t + n >>> 1; At(ie[s]) < e ? t = s + 1 : n = s } return t } function Zn(e) { (!ie.length || !ie.includes(e, It && e.allowRecurse ? Ae + 1 : Ae)) && (e.id == null ? ie.push(e) : ie.splice(Mo(e.id), 0, e), ir()) } function ir() { !It && !In && (In = !0, Vn = lr.then(fr)) } function Po(e) { const t = ie.indexOf(e); t > Ae && ie.splice(t, 1) } function $o(e) { $(e) ? ft.push(...e) : (!Re || !Re.includes(e, e.allowRecurse ? Ze + 1 : Ze)) && ft.push(e), ir() } function hs(e, t = It ? Ae + 1 : 0) { for (; t < ie.length; t++) { const n = ie[t]; n && n.pre && (ie.splice(t, 1), t--, n()) } } function cr(e) { if (ft.length) { const t = [...new Set(ft)]; if (ft.length = 0, Re) { Re.push(...t); return } for (Re = t, Re.sort((n, s) => At(n) - At(s)), Ze = 0; Ze < Re.length; Ze++)Re[Ze](); Re = null, Ze = 0 } } const At = e => e.id == null ? 1 / 0 : e.id, Ro = (e, t) => { const n = At(e) - At(t); if (n === 0) { if (e.pre && !t.pre) return -1; if (t.pre && !e.pre) return 1 } return n }; function fr(e) { In = !1, It = !0, ie.sort(Ro); const t = ye; try { for (Ae = 0; Ae < ie.length; Ae++) { const n = ie[Ae]; n && n.active !== !1 && Ke(n, null, 14) } } finally { Ae = 0, ie.length = 0, cr(), It = !1, Vn = null, (ie.length || ft.length) && fr() } } function Fo(e, t, ...n) { if (e.isUnmounted) return; const s = e.vnode.props || J; let r = n; const o = t.startsWith("update:"), l = o && t.slice(7); if (l && l in s) { const _ = `${l === "modelValue" ? "model" : l}Modifiers`, { number: b, trim: C } = s[_] || J; C && (r = n.map(M => te(M) ? M.trim() : M)), b && (r = n.map(jr)) } let c, u = s[c = hn(t)] || s[c = hn(ut(t))]; !u && o && (u = s[c = hn(pt(t))]), u && Ee(u, e, 6, r); const a = s[c + "Once"]; if (a) { if (!e.emitted) e.emitted = {}; else if (e.emitted[c]) return; e.emitted[c] = !0, Ee(a, e, 6, r) } } function ur(e, t, n = !1) { const s = t.emitsCache, r = s.get(e); if (r !== void 0) return r; const o = e.emits; let l = {}, c = !1; if (!N(e)) { const u = a => { const _ = ur(a, t, !0); _ && (c = !0, se(l, _)) }; !n && t.mixins.length && t.mixins.forEach(u), e.extends && u(e.extends), e.mixins && e.mixins.forEach(u) } return !o && !c ? (Z(e) && s.set(e, null), null) : ($(o) ? o.forEach(u => l[u] = null) : se(l, o), Z(e) && s.set(e, l), l) } function on(e, t) { return !e || !en(t) ? !1 : (t = t.slice(2).replace(/Once$/, ""), H(e, t[0].toLowerCase() + t.slice(1)) || H(e, pt(t)) || H(e, t)) } let Me = null, ln = null; function Yt(e) { const t = Me; return Me = e, ln = e && e.type.__scopeId || null, t } function No(e) { ln = e } function Lo() { ln = null } function Bo(e, t = Me, n) { if (!t || e._n) return e; const s = (...r) => { s._d && Es(-1); const o = Yt(t); let l; try { l = e(...r) } finally { Yt(o), s._d && Es(1) } return l }; return s._n = !0, s._c = !0, s._d = !0, s } function _n(e) { const { type: t, vnode: n, proxy: s, withProxy: r, props: o, propsOptions: [l], slots: c, attrs: u, emit: a, render: _, renderCache: b, data: C, setupState: M, ctx: K, inheritAttrs: F } = e; let V, S; const ee = Yt(e); try { if (n.shapeFlag & 4) { const R = r || s; V = Ie(_.call(R, R, b, o, M, C, K)), S = u } else { const R = t; V = Ie(R.length > 1 ? R(o, { attrs: u, slots: c, emit: a }) : R(o, null)), S = t.props ? u : Ho(u) } } catch (R) { Et.length = 0, rn(R, e, 1), V = ae(Mt) } let Q = V; if (S && F !== !1) { const R = Object.keys(S), { shapeFlag: pe } = Q; R.length && pe & 7 && (l && R.some(Ln) && (S = jo(S, l)), Q = dt(Q, S)) } return n.dirs && (Q = dt(Q), Q.dirs = Q.dirs ? Q.dirs.concat(n.dirs) : n.dirs), n.transition && (Q.transition = n.transition), V = Q, Yt(ee), V } const Ho = e => { let t; for (const n in e) (n === "class" || n === "style" || en(n)) && ((t || (t = {}))[n] = e[n]); return t }, jo = (e, t) => { const n = {}; for (const s in e) (!Ln(s) || !(s.slice(9) in t)) && (n[s] = e[s]); return n }; function Do(e, t, n) { const { props: s, children: r, component: o } = e, { props: l, children: c, patchFlag: u } = t, a = o.emitsOptions; if (t.dirs || t.transition) return !0; if (n && u >= 0) { if (u & 1024) return !0; if (u & 16) return s ? ps(s, l, a) : !!l; if (u & 8) { const _ = t.dynamicProps; for (let b = 0; b < _.length; b++) { const C = _[b]; if (l[C] !== s[C] && !on(a, C)) return !0 } } } else return (r || c) && (!c || !c.$stable) ? !0 : s === l ? !1 : s ? l ? ps(s, l, a) : !0 : !!l; return !1 } function ps(e, t, n) { const s = Object.keys(t); if (s.length !== Object.keys(e).length) return !0; for (let r = 0; r < s.length; r++) { const o = s[r]; if (t[o] !== e[o] && !on(n, o)) return !0 } return !1 } function So({ vnode: e, parent: t }, n) { for (; t && t.subTree === e;)(e = t.vnode).el = n, t = t.parent } const ko = e => e.__isSuspense; function Uo(e, t) { t && t.pendingBranch ? $(e) ? t.effects.push(...e) : t.effects.push(e) : $o(e) } const Ut = {}; function gn(e, t, n) { return ar(e, t, n) } function ar(e, t, { immediate: n, deep: s, flush: r, onTrack: o, onTrigger: l } = J) { var c; const u = Jr() === ((c = ce) == null ? void 0 : c.scope) ? ce : null; let a, _ = !1, b = !1; if (fe(e) ? (a = () => e.value, _ = Qt(e)) : ct(e) ? (a = () => e, s = !0) : $(e) ? (b = !0, _ = e.some(R => ct(R) || Qt(R)), a = () => e.map(R => { if (fe(R)) return R.value; if (ct(R)) return ot(R); if (N(R)) return Ke(R, u, 2) })) : N(e) ? t ? a = () => Ke(e, u, 2) : a = () => { if (!(u && u.isUnmounted)) return C && C(), Ee(e, u, 3, [M]) } : a = ye, t && s) { const R = a; a = () => ot(R()) } let C, M = R => { C = ee.onStop = () => { Ke(R, u, 4) } }, K; if ($t) if (M = ye, t ? n && Ee(t, u, 3, [a(), b ? [] : void 0, M]) : a(), r === "sync") { const R = Ll(); K = R.__watcherHandles || (R.__watcherHandles = []) } else return ye; let F = b ? new Array(e.length).fill(Ut) : Ut; const V = () => { if (ee.active) if (t) { const R = ee.run(); (s || _ || (b ? R.some((pe, Le) => Ct(pe, F[Le])) : Ct(R, F))) && (C && C(), Ee(t, u, 3, [R, F === Ut ? void 0 : b && F[0] === Ut ? [] : F, M]), F = R) } else ee.run() }; V.allowRecurse = !!t; let S; r === "sync" ? S = V : r === "post" ? S = () => de(V, u && u.suspense) : (V.pre = !0, u && (V.id = u.uid), S = () => Zn(V)); const ee = new kn(a, S); t ? n ? V() : F = ee.run() : r === "post" ? de(ee.run.bind(ee), u && u.suspense) : ee.run(); const Q = () => { ee.stop(), u && u.scope && Bn(u.scope.effects, ee) }; return K && K.push(Q), Q } function Ko(e, t, n) { const s = this.proxy, r = te(e) ? e.includes(".") ? dr(s, e) : () => s[e] : e.bind(s, s); let o; N(t) ? o = t : (o = t.handler, n = t); const l = ce; ht(this); const c = ar(r, o.bind(s), n); return l ? ht(l) : Xe(), c } function dr(e, t) { const n = t.split("."); return () => { let s = e; for (let r = 0; r < n.length && s; r++)s = s[n[r]]; return s } } function ot(e, t) { if (!Z(e) || e.__v_skip || (t = t || new Set, t.has(e))) return e; if (t.add(e), fe(e)) ot(e.value, t); else if ($(e)) for (let n = 0; n < e.length; n++)ot(e[n], t); else if (Hs(e) || it(e)) e.forEach(n => { ot(n, t) }); else if (Ss(e)) for (const n in e) ot(e[n], t); return e } function Je(e, t, n, s) { const r = e.dirs, o = t && t.dirs; for (let l = 0; l < r.length; l++) { const c = r[l]; o && (c.oldValue = o[l].value); let u = c.dir[s]; u && (_t(), Ee(u, n, 8, [e.el, c, e, t]), gt()) } } function hr(e, t) { return N(e) ? (() => se({ name: e.name }, t, { setup: e }))() : e } const qt = e => !!e.type.__asyncLoader, pr = e => e.type.__isKeepAlive; function Wo(e, t) { _r(e, "a", t) } function zo(e, t) { _r(e, "da", t) } function _r(e, t, n = ce) { const s = e.__wdc || (e.__wdc = () => { let r = n; for (; r;) { if (r.isDeactivated) return; r = r.parent } return e() }); if (cn(t, s, n), n) { let r = n.parent; for (; r && r.parent;)pr(r.parent.vnode) && qo(s, t, n, r), r = r.parent } } function qo(e, t, n, s) { const r = cn(t, e, s, !0); mr(() => { Bn(s[t], r) }, n) } function cn(e, t, n = ce, s = !1) { if (n) { const r = n[e] || (n[e] = []), o = t.__weh || (t.__weh = (...l) => { if (n.isUnmounted) return; _t(), ht(n); const c = Ee(t, n, e, l); return Xe(), gt(), c }); return s ? r.unshift(o) : r.push(o), o } } const Ne = e => (t, n = ce) => (!$t || e === "sp") && cn(e, (...s) => t(...s), n), Jo = Ne("bm"), gr = Ne("m"), Vo = Ne("bu"), Zo = Ne("u"), Qo = Ne("bum"), mr = Ne("um"), Yo = Ne("sp"), Xo = Ne("rtg"), Go = Ne("rtc"); function el(e, t = ce) { cn("ec", e, t) } const tl = Symbol.for("v-ndc"); function Kt(e, t, n, s) { let r; const o = n && n[s]; if ($(e) || te(e)) { r = new Array(e.length); for (let l = 0, c = e.length; l < c; l++)r[l] = t(e[l], l, void 0, o && o[l]) } else if (typeof e == "number") { r = new Array(e); for (let l = 0; l < e; l++)r[l] = t(l + 1, l, void 0, o && o[l]) } else if (Z(e)) if (e[Symbol.iterator]) r = Array.from(e, (l, c) => t(l, c, void 0, o && o[c])); else { const l = Object.keys(e); r = new Array(l.length); for (let c = 0, u = l.length; c < u; c++) { const a = l[c]; r[c] = t(e[a], a, c, o && o[c]) } } else r = []; return n && (n[s] = r), r } const An = e => e ? Ar(e) ? es(e) || e.proxy : An(e.parent) : null, yt = se(Object.create(null), { $: e => e, $el: e => e.vnode.el, $data: e => e.data, $props: e => e.props, $attrs: e => e.attrs, $slots: e => e.slots, $refs: e => e.refs, $parent: e => An(e.parent), $root: e => An(e.root), $emit: e => e.emit, $options: e => Qn(e), $forceUpdate: e => e.f || (e.f = () => Zn(e.update)), $nextTick: e => e.n || (e.n = Ao.bind(e.proxy)), $watch: e => Ko.bind(e) }), mn = (e, t) => e !== J && !e.__isScriptSetup && H(e, t), nl = { get({ _: e }, t) { const { ctx: n, setupState: s, data: r, props: o, accessCache: l, type: c, appContext: u } = e; let a; if (t[0] !== "$") { const M = l[t]; if (M !== void 0) switch (M) { case 1: return s[t]; case 2: return r[t]; case 4: return n[t]; case 3: return o[t] } else { if (mn(s, t)) return l[t] = 1, s[t]; if (r !== J && H(r, t)) return l[t] = 2, r[t]; if ((a = e.propsOptions[0]) && H(a, t)) return l[t] = 3, o[t]; if (n !== J && H(n, t)) return l[t] = 4, n[t]; Mn && (l[t] = 0) } } const _ = yt[t]; let b, C; if (_) return t === "$attrs" && he(e, "get", t), _(e); if ((b = c.__cssModules) && (b = b[t])) return b; if (n !== J && H(n, t)) return l[t] = 4, n[t]; if (C = u.config.globalProperties, H(C, t)) return C[t] }, set({ _: e }, t, n) { const { data: s, setupState: r, ctx: o } = e; return mn(r, t) ? (r[t] = n, !0) : s !== J && H(s, t) ? (s[t] = n, !0) : H(e.props, t) || t[0] === "$" && t.slice(1) in e ? !1 : (o[t] = n, !0) }, has({ _: { data: e, setupState: t, accessCache: n, ctx: s, appContext: r, propsOptions: o } }, l) { let c; return !!n[l] || e !== J && H(e, l) || mn(t, l) || (c = o[0]) && H(c, l) || H(s, l) || H(yt, l) || H(r.config.globalProperties, l) }, defineProperty(e, t, n) { return n.get != null ? e._.accessCache[t] = 0 : H(n, "value") && this.set(e, t, n.value, null), Reflect.defineProperty(e, t, n) } }; function _s(e) { return $(e) ? e.reduce((t, n) => (t[n] = null, t), {}) : e } let Mn = !0; function sl(e) { const t = Qn(e), n = e.proxy, s = e.ctx; Mn = !1, t.beforeCreate && gs(t.beforeCreate, e, "bc"); const { data: r, computed: o, methods: l, watch: c, provide: u, inject: a, created: _, beforeMount: b, mounted: C, beforeUpdate: M, updated: K, activated: F, deactivated: V, beforeDestroy: S, beforeUnmount: ee, destroyed: Q, unmounted: R, render: pe, renderTracked: Le, renderTriggered: Be, errorCaptured: Ce, serverPrefetch: ze, expose: Y, inheritAttrs: Pe, components: He, directives: et, filters: je } = t; if (a && rl(a, s, null), l) for (const E in l) { const w = l[E]; N(w) && (s[E] = w.bind(n)) } if (r) { const E = r.call(n, n); Z(E) && (e.data = zn(E)) } if (Mn = !0, o) for (const E in o) { const w = o[E], O = N(w) ? w.bind(n, n) : N(w.get) ? w.get.bind(n, n) : ye, k = !N(w) && N(w.set) ? w.set.bind(n) : ye, j = Pr({ get: O, set: k }); Object.defineProperty(s, E, { enumerable: !0, configurable: !0, get: () => j.value, set: z => j.value = z }) } if (c) for (const E in c) vr(c[E], s, n, E); if (u) { const E = N(u) ? u.call(n) : u; Reflect.ownKeys(E).forEach(w => { ul(w, E[w]) }) } _ && gs(_, e, "c"); function ne(E, w) { $(w) ? w.forEach(O => E(O.bind(n))) : w && E(w.bind(n)) } if (ne(Jo, b), ne(gr, C), ne(Vo, M), ne(Zo, K), ne(Wo, F), ne(zo, V), ne(el, Ce), ne(Go, Le), ne(Xo, Be), ne(Qo, ee), ne(mr, R), ne(Yo, ze), $(Y)) if (Y.length) { const E = e.exposed || (e.exposed = {}); Y.forEach(w => { Object.defineProperty(E, w, { get: () => n[w], set: O => n[w] = O }) }) } else e.exposed || (e.exposed = {}); pe && e.render === ye && (e.render = pe), Pe != null && (e.inheritAttrs = Pe), He && (e.components = He), et && (e.directives = et) } function rl(e, t, n = ye) { $(e) && (e = Pn(e)); for (const s in e) { const r = e[s]; let o; Z(r) ? "default" in r ? o = Jt(r.from || s, r.default, !0) : o = Jt(r.from || s) : o = Jt(r), fe(o) ? Object.defineProperty(t, s, { enumerable: !0, configurable: !0, get: () => o.value, set: l => o.value = l }) : t[s] = o } } function gs(e, t, n) { Ee($(e) ? e.map(s => s.bind(t.proxy)) : e.bind(t.proxy), t, n) } function vr(e, t, n, s) { const r = s.includes(".") ? dr(n, s) : () => n[s]; if (te(e)) { const o = t[e]; N(o) && gn(r, o) } else if (N(e)) gn(r, e.bind(n)); else if (Z(e)) if ($(e)) e.forEach(o => vr(o, t, n, s)); else { const o = N(e.handler) ? e.handler.bind(n) : t[e.handler]; N(o) && gn(r, o, e) } } function Qn(e) { const t = e.type, { mixins: n, extends: s } = t, { mixins: r, optionsCache: o, config: { optionMergeStrategies: l } } = e.appContext, c = o.get(t); let u; return c ? u = c : !r.length && !n && !s ? u = t : (u = {}, r.length && r.forEach(a => Xt(u, a, l, !0)), Xt(u, t, l)), Z(t) && o.set(t, u), u } function Xt(e, t, n, s = !1) { const { mixins: r, extends: o } = t; o && Xt(e, o, n, !0), r && r.forEach(l => Xt(e, l, n, !0)); for (const l in t) if (!(s && l === "expose")) { const c = ol[l] || n && n[l]; e[l] = c ? c(e[l], t[l]) : t[l] } return e } const ol = { data: ms, props: vs, emits: vs, methods: wt, computed: wt, beforeCreate: ue, created: ue, beforeMount: ue, mounted: ue, beforeUpdate: ue, updated: ue, beforeDestroy: ue, beforeUnmount: ue, destroyed: ue, unmounted: ue, activated: ue, deactivated: ue, errorCaptured: ue, serverPrefetch: ue, components: wt, directives: wt, watch: il, provide: ms, inject: ll }; function ms(e, t) { return t ? e ? function () { return se(N(e) ? e.call(this, this) : e, N(t) ? t.call(this, this) : t) } : t : e } function ll(e, t) { return wt(Pn(e), Pn(t)) } function Pn(e) { if ($(e)) { const t = {}; for (let n = 0; n < e.length; n++)t[e[n]] = e[n]; return t } return e } function ue(e, t) { return e ? [...new Set([].concat(e, t))] : t } function wt(e, t) { return e ? se(Object.create(null), e, t) : t } function vs(e, t) { return e ? $(e) && $(t) ? [...new Set([...e, ...t])] : se(Object.create(null), _s(e), _s(t ?? {})) : t } function il(e, t) { if (!e) return t; if (!t) return e; const n = se(Object.create(null), e); for (const s in t) n[s] = ue(e[s], t[s]); return n } function br() { return { app: null, config: { isNativeTag: Rr, performance: !1, globalProperties: {}, optionMergeStrategies: {}, errorHandler: void 0, warnHandler: void 0, compilerOptions: {} }, mixins: [], components: {}, directives: {}, provides: Object.create(null), optionsCache: new WeakMap, propsCache: new WeakMap, emitsCache: new WeakMap } } let cl = 0; function fl(e, t) { return function (s, r = null) { N(s) || (s = se({}, s)), r != null && !Z(r) && (r = null); const o = br(), l = new Set; let c = !1; const u = o.app = { _uid: cl++, _component: s, _props: r, _container: null, _context: o, _instance: null, version: Bl, get config() { return o.config }, set config(a) { }, use(a, ..._) { return l.has(a) || (a && N(a.install) ? (l.add(a), a.install(u, ..._)) : N(a) && (l.add(a), a(u, ..._))), u }, mixin(a) { return o.mixins.includes(a) || o.mixins.push(a), u }, component(a, _) { return _ ? (o.components[a] = _, u) : o.components[a] }, directive(a, _) { return _ ? (o.directives[a] = _, u) : o.directives[a] }, mount(a, _, b) { if (!c) { const C = ae(s, r); return C.appContext = o, _ && t ? t(C, a) : e(C, a, b), c = !0, u._container = a, a.__vue_app__ = u, es(C.component) || C.component.proxy } }, unmount() { c && (e(null, u._container), delete u._container.__vue_app__) }, provide(a, _) { return o.provides[a] = _, u }, runWithContext(a) { Gt = u; try { return a() } finally { Gt = null } } }; return u } } let Gt = null; function ul(e, t) { if (ce) { let n = ce.provides; const s = ce.parent && ce.parent.provides; s === n && (n = ce.provides = Object.create(s)), n[e] = t } } function Jt(e, t, n = !1) { const s = ce || Me; if (s || Gt) { const r = s ? s.parent == null ? s.vnode.appContext && s.vnode.appContext.provides : s.parent.provides : Gt._context.provides; if (r && e in r) return r[e]; if (arguments.length > 1) return n && N(t) ? t.call(s && s.proxy) : t } } function al(e, t, n, s = !1) { const r = {}, o = {}; Zt(o, un, 1), e.propsDefaults = Object.create(null), xr(e, t, r, o); for (const l in e.propsOptions[0]) l in r || (r[l] = void 0); n ? e.props = s ? r : wo(r) : e.type.props ? e.props = r : e.props = o, e.attrs = o } function dl(e, t, n, s) { const { props: r, attrs: o, vnode: { patchFlag: l } } = e, c = D(r), [u] = e.propsOptions; let a = !1; if ((s || l > 0) && !(l & 16)) { if (l & 8) { const _ = e.vnode.dynamicProps; for (let b = 0; b < _.length; b++) { let C = _[b]; if (on(e.emitsOptions, C)) continue; const M = t[C]; if (u) if (H(o, C)) M !== o[C] && (o[C] = M, a = !0); else { const K = ut(C); r[K] = $n(u, c, K, M, e, !1) } else M !== o[C] && (o[C] = M, a = !0) } } } else { xr(e, t, r, o) && (a = !0); let _; for (const b in c) (!t || !H(t, b) && ((_ = pt(b)) === b || !H(t, _))) && (u ? n && (n[b] !== void 0 || n[_] !== void 0) && (r[b] = $n(u, c, b, void 0, e, !0)) : delete r[b]); if (o !== c) for (const b in o) (!t || !H(t, b)) && (delete o[b], a = !0) } a && Fe(e, "set", "$attrs") } function xr(e, t, n, s) { const [r, o] = e.propsOptions; let l = !1, c; if (t) for (let u in t) { if (zt(u)) continue; const a = t[u]; let _; r && H(r, _ = ut(u)) ? !o || !o.includes(_) ? n[_] = a : (c || (c = {}))[_] = a : on(e.emitsOptions, u) || (!(u in s) || a !== s[u]) && (s[u] = a, l = !0) } if (o) { const u = D(n), a = c || J; for (let _ = 0; _ < o.length; _++) { const b = o[_]; n[b] = $n(r, u, b, a[b], e, !H(a, b)) } } return l } function $n(e, t, n, s, r, o) { const l = e[n]; if (l != null) { const c = H(l, "default"); if (c && s === void 0) { const u = l.default; if (l.type !== Function && !l.skipFactory && N(u)) { const { propsDefaults: a } = r; n in a ? s = a[n] : (ht(r), s = a[n] = u.call(null, t), Xe()) } else s = u } l[0] && (o && !c ? s = !1 : l[1] && (s === "" || s === pt(n)) && (s = !0)) } return s } function wr(e, t, n = !1) { const s = t.propsCache, r = s.get(e); if (r) return r; const o = e.props, l = {}, c = []; let u = !1; if (!N(e)) { const _ = b => { u = !0; const [C, M] = wr(b, t, !0); se(l, C), M && c.push(...M) }; !n && t.mixins.length && t.mixins.forEach(_), e.extends && _(e.extends), e.mixins && e.mixins.forEach(_) } if (!o && !u) return Z(e) && s.set(e, lt), lt; if ($(o)) for (let _ = 0; _ < o.length; _++) { const b = ut(o[_]); bs(b) && (l[b] = J) } else if (o) for (const _ in o) { const b = ut(_); if (bs(b)) { const C = o[_], M = l[b] = $(C) || N(C) ? { type: C } : se({}, C); if (M) { const K = ys(Boolean, M.type), F = ys(String, M.type); M[0] = K > -1, M[1] = F < 0 || K < F, (K > -1 || H(M, "default")) && c.push(b) } } } const a = [l, c]; return Z(e) && s.set(e, a), a } function bs(e) { return e[0] !== "$" } function xs(e) { const t = e && e.toString().match(/^\s*(function|class) (\w+)/); return t ? t[2] : e === null ? "null" : "" } function ws(e, t) { return xs(e) === xs(t) } function ys(e, t) { return $(t) ? t.findIndex(n => ws(n, e)) : N(t) && ws(t, e) ? 0 : -1 } const yr = e => e[0] === "_" || e === "$stable", Yn = e => $(e) ? e.map(Ie) : [Ie(e)], hl = (e, t, n) => { if (t._n) return t; const s = Bo((...r) => Yn(t(...r)), n); return s._c = !1, s }, Er = (e, t, n) => { const s = e._ctx; for (const r in e) { if (yr(r)) continue; const o = e[r]; if (N(o)) t[r] = hl(r, o, s); else if (o != null) { const l = Yn(o); t[r] = () => l } } }, Cr = (e, t) => { const n = Yn(t); e.slots.default = () => n }, pl = (e, t) => { if (e.vnode.shapeFlag & 32) { const n = t._; n ? (e.slots = D(t), Zt(t, "_", n)) : Er(t, e.slots = {}) } else e.slots = {}, t && Cr(e, t); Zt(e.slots, un, 1) }, _l = (e, t, n) => { const { vnode: s, slots: r } = e; let o = !0, l = J; if (s.shapeFlag & 32) { const c = t._; c ? n && c === 1 ? o = !1 : (se(r, t), !n && c === 1 && delete r._) : (o = !t.$stable, Er(t, r)), l = t } else t && (Cr(e, t), l = { default: 1 }); if (o) for (const c in r) !yr(c) && !(c in l) && delete r[c] }; function Rn(e, t, n, s, r = !1) { if ($(e)) { e.forEach((C, M) => Rn(C, t && ($(t) ? t[M] : t), n, s, r)); return } if (qt(s) && !r) return; const o = s.shapeFlag & 4 ? es(s.component) || s.component.proxy : s.el, l = r ? null : o, { i: c, r: u } = e, a = t && t.r, _ = c.refs === J ? c.refs = {} : c.refs, b = c.setupState; if (a != null && a !== u && (te(a) ? (_[a] = null, H(b, a) && (b[a] = null)) : fe(a) && (a.value = null)), N(u)) Ke(u, c, 12, [l, _]); else { const C = te(u), M = fe(u); if (C || M) { const K = () => { if (e.f) { const F = C ? H(b, u) ? b[u] : _[u] : u.value; r ? $(F) && Bn(F, o) : $(F) ? F.includes(o) || F.push(o) : C ? (_[u] = [o], H(b, u) && (b[u] = _[u])) : (u.value = [o], e.k && (_[e.k] = u.value)) } else C ? (_[u] = l, H(b, u) && (b[u] = l)) : M && (u.value = l, e.k && (_[e.k] = l)) }; l ? (K.id = -1, de(K, n)) : K() } } } const de = Uo; function gl(e) { return ml(e) } function ml(e, t) { const n = yn(); n.__VUE__ = !0; const { insert: s, remove: r, patchProp: o, createElement: l, createText: c, createComment: u, setText: a, setElementText: _, parentNode: b, nextSibling: C, setScopeId: M = ye, insertStaticContent: K } = e, F = (i, f, d, p = null, h = null, v = null, y = !1, m = null, x = !!f.dynamicChildren) => { if (i === f) return; i && !vt(i, f) && (p = Lt(i), z(i, h, v, !0), i = null), f.patchFlag === -2 && (x = !1, f.dynamicChildren = null); const { type: g, ref: I, shapeFlag: T } = f; switch (g) { case fn: V(i, f, d, p); break; case Mt: S(i, f, d, p); break; case vn: i == null && ee(f, d, p, y); break; case ge: He(i, f, d, p, h, v, y, m, x); break; default: T & 1 ? pe(i, f, d, p, h, v, y, m, x) : T & 6 ? et(i, f, d, p, h, v, y, m, x) : (T & 64 || T & 128) && g.process(i, f, d, p, h, v, y, m, x, tt) }I != null && h && Rn(I, i && i.ref, v, f || i, !f) }, V = (i, f, d, p) => { if (i == null) s(f.el = c(f.children), d, p); else { const h = f.el = i.el; f.children !== i.children && a(h, f.children) } }, S = (i, f, d, p) => { i == null ? s(f.el = u(f.children || ""), d, p) : f.el = i.el }, ee = (i, f, d, p) => { [i.el, i.anchor] = K(i.children, f, d, p, i.el, i.anchor) }, Q = ({ el: i, anchor: f }, d, p) => { let h; for (; i && i !== f;)h = C(i), s(i, d, p), i = h; s(f, d, p) }, R = ({ el: i, anchor: f }) => { let d; for (; i && i !== f;)d = C(i), r(i), i = d; r(f) }, pe = (i, f, d, p, h, v, y, m, x) => { y = y || f.type === "svg", i == null ? Le(f, d, p, h, v, y, m, x) : ze(i, f, h, v, y, m, x) }, Le = (i, f, d, p, h, v, y, m) => { let x, g; const { type: I, props: T, shapeFlag: A, transition: P, dirs: B } = i; if (x = i.el = l(i.type, v, T && T.is, T), A & 8 ? _(x, i.children) : A & 16 && Ce(i.children, x, null, p, h, v && I !== "foreignObject", y, m), B && Je(i, null, p, "created"), Be(x, i, i.scopeId, y, p), T) { for (const U in T) U !== "value" && !zt(U) && o(x, U, null, T[U], v, i.children, p, h, me); "value" in T && o(x, "value", null, T.value), (g = T.onVnodeBeforeMount) && Te(g, p, i) } B && Je(i, null, p, "beforeMount"); const W = (!h || h && !h.pendingBranch) && P && !P.persisted; W && P.beforeEnter(x), s(x, f, d), ((g = T && T.onVnodeMounted) || W || B) && de(() => { g && Te(g, p, i), W && P.enter(x), B && Je(i, null, p, "mounted") }, h) }, Be = (i, f, d, p, h) => { if (d && M(i, d), p) for (let v = 0; v < p.length; v++)M(i, p[v]); if (h) { let v = h.subTree; if (f === v) { const y = h.vnode; Be(i, y, y.scopeId, y.slotScopeIds, h.parent) } } }, Ce = (i, f, d, p, h, v, y, m, x = 0) => { for (let g = x; g < i.length; g++) { const I = i[g] = m ? ke(i[g]) : Ie(i[g]); F(null, I, f, d, p, h, v, y, m) } }, ze = (i, f, d, p, h, v, y) => { const m = f.el = i.el; let { patchFlag: x, dynamicChildren: g, dirs: I } = f; x |= i.patchFlag & 16; const T = i.props || J, A = f.props || J; let P; d && Ve(d, !1), (P = A.onVnodeBeforeUpdate) && Te(P, d, f, i), I && Je(f, i, d, "beforeUpdate"), d && Ve(d, !0); const B = h && f.type !== "foreignObject"; if (g ? Y(i.dynamicChildren, g, m, d, p, B, v) : y || w(i, f, m, null, d, p, B, v, !1), x > 0) { if (x & 16) Pe(m, f, T, A, d, p, h); else if (x & 2 && T.class !== A.class && o(m, "class", null, A.class, h), x & 4 && o(m, "style", T.style, A.style, h), x & 8) { const W = f.dynamicProps; for (let U = 0; U < W.length; U++) { const X = W[U], ve = T[X], nt = A[X]; (nt !== ve || X === "value") && o(m, X, ve, nt, h, i.children, d, p, me) } } x & 1 && i.children !== f.children && _(m, f.children) } else !y && g == null && Pe(m, f, T, A, d, p, h); ((P = A.onVnodeUpdated) || I) && de(() => { P && Te(P, d, f, i), I && Je(f, i, d, "updated") }, p) }, Y = (i, f, d, p, h, v, y) => { for (let m = 0; m < f.length; m++) { const x = i[m], g = f[m], I = x.el && (x.type === ge || !vt(x, g) || x.shapeFlag & 70) ? b(x.el) : d; F(x, g, I, null, p, h, v, y, !0) } }, Pe = (i, f, d, p, h, v, y) => { if (d !== p) { if (d !== J) for (const m in d) !zt(m) && !(m in p) && o(i, m, d[m], null, y, f.children, h, v, me); for (const m in p) { if (zt(m)) continue; const x = p[m], g = d[m]; x !== g && m !== "value" && o(i, m, g, x, y, f.children, h, v, me) } "value" in p && o(i, "value", d.value, p.value) } }, He = (i, f, d, p, h, v, y, m, x) => { const g = f.el = i ? i.el : c(""), I = f.anchor = i ? i.anchor : c(""); let { patchFlag: T, dynamicChildren: A, slotScopeIds: P } = f; P && (m = m ? m.concat(P) : P), i == null ? (s(g, d, p), s(I, d, p), Ce(f.children, d, I, h, v, y, m, x)) : T > 0 && T & 64 && A && i.dynamicChildren ? (Y(i.dynamicChildren, A, d, h, v, y, m), (f.key != null || h && f === h.subTree) && Or(i, f, !0)) : w(i, f, d, I, h, v, y, m, x) }, et = (i, f, d, p, h, v, y, m, x) => { f.slotScopeIds = m, i == null ? f.shapeFlag & 512 ? h.ctx.activate(f, d, p, y, x) : je(f, d, p, h, v, y, x) : Ft(i, f, x) }, je = (i, f, d, p, h, v, y) => { const m = i.component = Al(i, p, h); if (pr(i) && (m.ctx.renderer = tt), Ml(m), m.asyncDep) { if (h && h.registerDep(m, ne), !i.el) { const x = m.subTree = ae(Mt); S(null, x, f, d) } return } ne(m, i, f, d, h, v, y) }, Ft = (i, f, d) => { const p = f.component = i.component; if (Do(i, f, d)) if (p.asyncDep && !p.asyncResolved) { E(p, f, d); return } else p.next = f, Po(p.update), p.update(); else f.el = i.el, p.vnode = f }, ne = (i, f, d, p, h, v, y) => { const m = () => { if (i.isMounted) { let { next: I, bu: T, u: A, parent: P, vnode: B } = i, W = I, U; Ve(i, !1), I ? (I.el = B.el, E(i, I, y)) : I = B, T && pn(T), (U = I.props && I.props.onVnodeBeforeUpdate) && Te(U, P, I, B), Ve(i, !0); const X = _n(i), ve = i.subTree; i.subTree = X, F(ve, X, b(ve.el), Lt(ve), i, h, v), I.el = X.el, W === null && So(i, X.el), A && de(A, h), (U = I.props && I.props.onVnodeUpdated) && de(() => Te(U, P, I, B), h) } else { let I; const { el: T, props: A } = f, { bm: P, m: B, parent: W } = i, U = qt(f); if (Ve(i, !1), P && pn(P), !U && (I = A && A.onVnodeBeforeMount) && Te(I, W, f), Ve(i, !0), T && dn) { const X = () => { i.subTree = _n(i), dn(T, i.subTree, i, h, null) }; U ? f.type.__asyncLoader().then(() => !i.isUnmounted && X()) : X() } else { const X = i.subTree = _n(i); F(null, X, d, p, i, h, v), f.el = X.el } if (B && de(B, h), !U && (I = A && A.onVnodeMounted)) { const X = f; de(() => Te(I, W, X), h) } (f.shapeFlag & 256 || W && qt(W.vnode) && W.vnode.shapeFlag & 256) && i.a && de(i.a, h), i.isMounted = !0, f = d = p = null } }, x = i.effect = new kn(m, () => Zn(g), i.scope), g = i.update = () => x.run(); g.id = i.uid, Ve(i, !0), g() }, E = (i, f, d) => { f.component = i; const p = i.vnode.props; i.vnode = f, i.next = null, dl(i, f.props, p, d), _l(i, f.children, d), _t(), hs(), gt() }, w = (i, f, d, p, h, v, y, m, x = !1) => { const g = i && i.children, I = i ? i.shapeFlag : 0, T = f.children, { patchFlag: A, shapeFlag: P } = f; if (A > 0) { if (A & 128) { k(g, T, d, p, h, v, y, m, x); return } else if (A & 256) { O(g, T, d, p, h, v, y, m, x); return } } P & 8 ? (I & 16 && me(g, h, v), T !== g && _(d, T)) : I & 16 ? P & 16 ? k(g, T, d, p, h, v, y, m, x) : me(g, h, v, !0) : (I & 8 && _(d, ""), P & 16 && Ce(T, d, p, h, v, y, m, x)) }, O = (i, f, d, p, h, v, y, m, x) => { i = i || lt, f = f || lt; const g = i.length, I = f.length, T = Math.min(g, I); let A; for (A = 0; A < T; A++) { const P = f[A] = x ? ke(f[A]) : Ie(f[A]); F(i[A], P, d, null, h, v, y, m, x) } g > I ? me(i, h, v, !0, !1, T) : Ce(f, d, p, h, v, y, m, x, T) }, k = (i, f, d, p, h, v, y, m, x) => { let g = 0; const I = f.length; let T = i.length - 1, A = I - 1; for (; g <= T && g <= A;) { const P = i[g], B = f[g] = x ? ke(f[g]) : Ie(f[g]); if (vt(P, B)) F(P, B, d, null, h, v, y, m, x); else break; g++ } for (; g <= T && g <= A;) { const P = i[T], B = f[A] = x ? ke(f[A]) : Ie(f[A]); if (vt(P, B)) F(P, B, d, null, h, v, y, m, x); else break; T--, A-- } if (g > T) { if (g <= A) { const P = A + 1, B = P < I ? f[P].el : p; for (; g <= A;)F(null, f[g] = x ? ke(f[g]) : Ie(f[g]), d, B, h, v, y, m, x), g++ } } else if (g > A) for (; g <= T;)z(i[g], h, v, !0), g++; else { const P = g, B = g, W = new Map; for (g = B; g <= A; g++) { const _e = f[g] = x ? ke(f[g]) : Ie(f[g]); _e.key != null && W.set(_e.key, g) } let U, X = 0; const ve = A - B + 1; let nt = !1, ns = 0; const mt = new Array(ve); for (g = 0; g < ve; g++)mt[g] = 0; for (g = P; g <= T; g++) { const _e = i[g]; if (X >= ve) { z(_e, h, v, !0); continue } let Oe; if (_e.key != null) Oe = W.get(_e.key); else for (U = B; U <= A; U++)if (mt[U - B] === 0 && vt(_e, f[U])) { Oe = U; break } Oe === void 0 ? z(_e, h, v, !0) : (mt[Oe - B] = g + 1, Oe >= ns ? ns = Oe : nt = !0, F(_e, f[Oe], d, null, h, v, y, m, x), X++) } const ss = nt ? vl(mt) : lt; for (U = ss.length - 1, g = ve - 1; g >= 0; g--) { const _e = B + g, Oe = f[_e], rs = _e + 1 < I ? f[_e + 1].el : p; mt[g] === 0 ? F(null, Oe, d, rs, h, v, y, m, x) : nt && (U < 0 || g !== ss[U] ? j(Oe, d, rs, 2) : U--) } } }, j = (i, f, d, p, h = null) => { const { el: v, type: y, transition: m, children: x, shapeFlag: g } = i; if (g & 6) { j(i.component.subTree, f, d, p); return } if (g & 128) { i.suspense.move(f, d, p); return } if (g & 64) { y.move(i, f, d, tt); return } if (y === ge) { s(v, f, d); for (let T = 0; T < x.length; T++)j(x[T], f, d, p); s(i.anchor, f, d); return } if (y === vn) { Q(i, f, d); return } if (p !== 2 && g & 1 && m) if (p === 0) m.beforeEnter(v), s(v, f, d), de(() => m.enter(v), h); else { const { leave: T, delayLeave: A, afterLeave: P } = m, B = () => s(v, f, d), W = () => { T(v, () => { B(), P && P() }) }; A ? A(v, B, W) : W() } else s(v, f, d) }, z = (i, f, d, p = !1, h = !1) => { const { type: v, props: y, ref: m, children: x, dynamicChildren: g, shapeFlag: I, patchFlag: T, dirs: A } = i; if (m != null && Rn(m, null, d, i, !0), I & 256) { f.ctx.deactivate(i); return } const P = I & 1 && A, B = !qt(i); let W; if (B && (W = y && y.onVnodeBeforeUnmount) && Te(W, f, i), I & 6) $e(i.component, d, p); else { if (I & 128) { i.suspense.unmount(d, p); return } P && Je(i, null, f, "beforeUnmount"), I & 64 ? i.type.remove(i, f, d, h, tt, p) : g && (v !== ge || T > 0 && T & 64) ? me(g, f, d, !1, !0) : (v === ge && T & 384 || !h && I & 16) && me(x, f, d), p && oe(i) } (B && (W = y && y.onVnodeUnmounted) || P) && de(() => { W && Te(W, f, i), P && Je(i, null, f, "unmounted") }, d) }, oe = i => { const { type: f, el: d, anchor: p, transition: h } = i; if (f === ge) { Nt(d, p); return } if (f === vn) { R(i); return } const v = () => { r(d), h && !h.persisted && h.afterLeave && h.afterLeave() }; if (i.shapeFlag & 1 && h && !h.persisted) { const { leave: y, delayLeave: m } = h, x = () => y(d, v); m ? m(i.el, v, x) : x() } else v() }, Nt = (i, f) => { let d; for (; i !== f;)d = C(i), r(i), i = d; r(f) }, $e = (i, f, d) => { const { bum: p, scope: h, update: v, subTree: y, um: m } = i; p && pn(p), h.stop(), v && (v.active = !1, z(y, i, f, d)), m && de(m, f), de(() => { i.isUnmounted = !0 }, f), f && f.pendingBranch && !f.isUnmounted && i.asyncDep && !i.asyncResolved && i.suspenseId === f.pendingId && (f.deps--, f.deps === 0 && f.resolve()) }, me = (i, f, d, p = !1, h = !1, v = 0) => { for (let y = v; y < i.length; y++)z(i[y], f, d, p, h) }, Lt = i => i.shapeFlag & 6 ? Lt(i.component.subTree) : i.shapeFlag & 128 ? i.suspense.next() : C(i.anchor || i.el), ts = (i, f, d) => { i == null ? f._vnode && z(f._vnode, null, null, !0) : F(f._vnode || null, i, f, null, null, null, d), hs(), cr(), f._vnode = i }, tt = { p: F, um: z, m: j, r: oe, mt: je, mc: Ce, pc: w, pbc: Y, n: Lt, o: e }; let an, dn; return t && ([an, dn] = t(tt)), { render: ts, hydrate: an, createApp: fl(ts, an) } } function Ve({ effect: e, update: t }, n) { e.allowRecurse = t.allowRecurse = n } function Or(e, t, n = !1) { const s = e.children, r = t.children; if ($(s) && $(r)) for (let o = 0; o < s.length; o++) { const l = s[o]; let c = r[o]; c.shapeFlag & 1 && !c.dynamicChildren && ((c.patchFlag <= 0 || c.patchFlag === 32) && (c = r[o] = ke(r[o]), c.el = l.el), n || Or(l, c)), c.type === fn && (c.el = l.el) } } function vl(e) { const t = e.slice(), n = [0]; let s, r, o, l, c; const u = e.length; for (s = 0; s < u; s++) { const a = e[s]; if (a !== 0) { if (r = n[n.length - 1], e[r] < a) { t[s] = r, n.push(s); continue } for (o = 0, l = n.length - 1; o < l;)c = o + l >> 1, e[n[c]] < a ? o = c + 1 : l = c; a < e[n[o]] && (o > 0 && (t[s] = n[o - 1]), n[o] = s) } } for (o = n.length, l = n[o - 1]; o-- > 0;)n[o] = l, l = t[l]; return n } const bl = e => e.__isTeleport, ge = Symbol.for("v-fgt"), fn = Symbol.for("v-txt"), Mt = Symbol.for("v-cmt"), vn = Symbol.for("v-stc"), Et = []; let we = null; function re(e = !1) { Et.push(we = e ? null : []) } function xl() { Et.pop(), we = Et[Et.length - 1] || null } let Pt = 1; function Es(e) { Pt += e } function Tr(e) { return e.dynamicChildren = Pt > 0 ? we || lt : null, xl(), Pt > 0 && we && we.push(e), e } function le(e, t, n, s, r, o) { return Tr(L(e, t, n, s, r, o, !0)) } function wl(e, t, n, s, r) { return Tr(ae(e, t, n, s, r, !0)) } function yl(e) { return e ? e.__v_isVNode === !0 : !1 } function vt(e, t) { return e.type === t.type && e.key === t.key } const un = "__vInternal", Ir = ({ key: e }) => e ?? null, Vt = ({ ref: e, ref_key: t, ref_for: n }) => (typeof e == "number" && (e = "" + e), e != null ? te(e) || fe(e) || N(e) ? { i: Me, r: e, k: t, f: !!n } : e : null); function L(e, t = null, n = null, s = 0, r = null, o = e === ge ? 0 : 1, l = !1, c = !1) { const u = { __v_isVNode: !0, __v_skip: !0, type: e, props: t, key: t && Ir(t), ref: t && Vt(t), scopeId: ln, slotScopeIds: null, children: n, component: null, suspense: null, ssContent: null, ssFallback: null, dirs: null, transition: null, el: null, anchor: null, target: null, targetAnchor: null, staticCount: 0, shapeFlag: o, patchFlag: s, dynamicProps: r, dynamicChildren: null, appContext: null, ctx: Me }; return c ? (Xn(u, n), o & 128 && e.normalize(u)) : n && (u.shapeFlag |= te(n) ? 8 : 16), Pt > 0 && !l && we && (u.patchFlag > 0 || o & 6) && u.patchFlag !== 32 && we.push(u), u } const ae = El; function El(e, t = null, n = null, s = 0, r = null, o = !1) { if ((!e || e === tl) && (e = Mt), yl(e)) { const c = dt(e, t, !0); return n && Xn(c, n), Pt > 0 && !o && we && (c.shapeFlag & 6 ? we[we.indexOf(e)] = c : we.push(c)), c.patchFlag |= -2, c } if (Fl(e) && (e = e.__vccOpts), t) { t = Cl(t); let { class: c, style: u } = t; c && !te(c) && (t.class = Dn(c)), Z(u) && (tr(u) && !$(u) && (u = se({}, u)), t.style = Ot(u)) } const l = te(e) ? 1 : ko(e) ? 128 : bl(e) ? 64 : Z(e) ? 4 : N(e) ? 2 : 0; return L(e, t, n, s, r, l, o, !0) } function Cl(e) { return e ? tr(e) || un in e ? se({}, e) : e : null } function dt(e, t, n = !1) { const { props: s, ref: r, patchFlag: o, children: l } = e, c = t ? Ol(s || {}, t) : s; return { __v_isVNode: !0, __v_skip: !0, type: e.type, props: c, key: c && Ir(c), ref: t && t.ref ? n && r ? $(r) ? r.concat(Vt(t)) : [r, Vt(t)] : Vt(t) : r, scopeId: e.scopeId, slotScopeIds: e.slotScopeIds, children: l, target: e.target, targetAnchor: e.targetAnchor, staticCount: e.staticCount, shapeFlag: e.shapeFlag, patchFlag: t && e.type !== ge ? o === -1 ? 16 : o | 16 : o, dynamicProps: e.dynamicProps, dynamicChildren: e.dynamicChildren, appContext: e.appContext, dirs: e.dirs, transition: e.transition, component: e.component, suspense: e.suspense, ssContent: e.ssContent && dt(e.ssContent), ssFallback: e.ssFallback && dt(e.ssFallback), el: e.el, anchor: e.anchor, ctx: e.ctx, ce: e.ce } } function Se(e = " ", t = 0) { return ae(fn, null, e, t) } function Ie(e) { return e == null || typeof e == "boolean" ? ae(Mt) : $(e) ? ae(ge, null, e.slice()) : typeof e == "object" ? ke(e) : ae(fn, null, String(e)) } function ke(e) { return e.el === null && e.patchFlag !== -1 || e.memo ? e : dt(e) } function Xn(e, t) { let n = 0; const { shapeFlag: s } = e; if (t == null) t = null; else if ($(t)) n = 16; else if (typeof t == "object") if (s & 65) { const r = t.default; r && (r._c && (r._d = !1), Xn(e, r()), r._c && (r._d = !0)); return } else { n = 32; const r = t._; !r && !(un in t) ? t._ctx = Me : r === 3 && Me && (Me.slots._ === 1 ? t._ = 1 : (t._ = 2, e.patchFlag |= 1024)) } else N(t) ? (t = { default: t, _ctx: Me }, n = 32) : (t = String(t), s & 64 ? (n = 16, t = [Se(t)]) : n = 8); e.children = t, e.shapeFlag |= n } function Ol(...e) { const t = {}; for (let n = 0; n < e.length; n++) { const s = e[n]; for (const r in s) if (r === "class") t.class !== s.class && (t.class = Dn([t.class, s.class])); else if (r === "style") t.style = Ot([t.style, s.style]); else if (en(r)) { const o = t[r], l = s[r]; l && o !== l && !($(o) && o.includes(l)) && (t[r] = o ? [].concat(o, l) : l) } else r !== "" && (t[r] = s[r]) } return t } function Te(e, t, n, s = null) { Ee(e, t, 7, [n, s]) } const Tl = br(); let Il = 0; function Al(e, t, n) { const s = e.type, r = (t ? t.appContext : e.appContext) || Tl, o = { uid: Il++, vnode: e, type: s, parent: t, appContext: r, root: null, next: null, subTree: null, effect: null, update: null, scope: new zr(!0), render: null, proxy: null, exposed: null, exposeProxy: null, withProxy: null, provides: t ? t.provides : Object.create(r.provides), accessCache: null, renderCache: [], components: null, directives: null, propsOptions: wr(s, r), emitsOptions: ur(s, r), emit: null, emitted: null, propsDefaults: J, inheritAttrs: s.inheritAttrs, ctx: J, data: J, props: J, attrs: J, slots: J, refs: J, setupState: J, setupContext: null, attrsProxy: null, slotsProxy: null, suspense: n, suspenseId: n ? n.pendingId : 0, asyncDep: null, asyncResolved: !1, isMounted: !1, isUnmounted: !1, isDeactivated: !1, bc: null, c: null, bm: null, m: null, bu: null, u: null, um: null, bum: null, da: null, a: null, rtg: null, rtc: null, ec: null, sp: null }; return o.ctx = { _: o }, o.root = t ? t.root : o, o.emit = Fo.bind(null, o), e.ce && e.ce(o), o } let ce = null, Gn, st, Cs = "__VUE_INSTANCE_SETTERS__"; (st = yn()[Cs]) || (st = yn()[Cs] = []), st.push(e => ce = e), Gn = e => { st.length > 1 ? st.forEach(t => t(e)) : st[0](e) }; const ht = e => { Gn(e), e.scope.on() }, Xe = () => { ce && ce.scope.off(), Gn(null) }; function Ar(e) { return e.vnode.shapeFlag & 4 } let $t = !1; function Ml(e, t = !1) { $t = t; const { props: n, children: s } = e.vnode, r = Ar(e); al(e, n, r, t), pl(e, s); const o = r ? Pl(e, t) : void 0; return $t = !1, o } function Pl(e, t) { const n = e.type; e.accessCache = Object.create(null), e.proxy = nr(new Proxy(e.ctx, nl)); const { setup: s } = n; if (s) { const r = e.setupContext = s.length > 1 ? Rl(e) : null; ht(e), _t(); const o = Ke(s, e, 0, [e.props, r]); if (gt(), Xe(), js(o)) { if (o.then(Xe, Xe), t) return o.then(l => { Os(e, l, t) }).catch(l => { rn(l, e, 0) }); e.asyncDep = o } else Os(e, o, t) } else Mr(e, t) } function Os(e, t, n) { N(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : Z(t) && (e.setupState = or(t)), Mr(e, n) } let Ts; function Mr(e, t, n) { const s = e.type; if (!e.render) { if (!t && Ts && !s.render) { const r = s.template || Qn(e).template; if (r) { const { isCustomElement: o, compilerOptions: l } = e.appContext.config, { delimiters: c, compilerOptions: u } = s, a = se(se({ isCustomElement: o, delimiters: c }, l), u); s.render = Ts(r, a) } } e.render = s.render || ye } ht(e), _t(), sl(e), gt(), Xe() } function $l(e) { return e.attrsProxy || (e.attrsProxy = new Proxy(e.attrs, { get(t, n) { return he(e, "get", "$attrs"), t[n] } })) } function Rl(e) { const t = n => { e.exposed = n || {} }; return { get attrs() { return $l(e) }, slots: e.slots, emit: e.emit, expose: t } } function es(e) { if (e.exposed) return e.exposeProxy || (e.exposeProxy = new Proxy(or(nr(e.exposed)), { get(t, n) { if (n in t) return t[n]; if (n in yt) return yt[n](e) }, has(t, n) { return n in t || n in yt } })) } function Fl(e) { return N(e) && "__vccOpts" in e } const Pr = (e, t) => To(e, t, $t), Nl = Symbol.for("v-scx"), Ll = () => Jt(Nl), Bl = "3.3.4", Hl = "http://www.w3.org/2000/svg", Qe = typeof document < "u" ? document : null, Is = Qe && Qe.createElement("template"), jl = { insert: (e, t, n) => { t.insertBefore(e, n || null) }, remove: e => { const t = e.parentNode; t && t.removeChild(e) }, createElement: (e, t, n, s) => { const r = t ? Qe.createElementNS(Hl, e) : Qe.createElement(e, n ? { is: n } : void 0); return e === "select" && s && s.multiple != null && r.setAttribute("multiple", s.multiple), r }, createText: e => Qe.createTextNode(e), createComment: e => Qe.createComment(e), setText: (e, t) => { e.nodeValue = t }, setElementText: (e, t) => { e.textContent = t }, parentNode: e => e.parentNode, nextSibling: e => e.nextSibling, querySelector: e => Qe.querySelector(e), setScopeId(e, t) { e.setAttribute(t, "") }, insertStaticContent(e, t, n, s, r, o) { const l = n ? n.previousSibling : t.lastChild; if (r && (r === o || r.nextSibling)) for (; t.insertBefore(r.cloneNode(!0), n), !(r === o || !(r = r.nextSibling));); else { Is.innerHTML = s ? `<svg>${e}</svg>` : e; const c = Is.content; if (s) { const u = c.firstChild; for (; u.firstChild;)c.appendChild(u.firstChild); c.removeChild(u) } t.insertBefore(c, n) } return [l ? l.nextSibling : t.firstChild, n ? n.previousSibling : t.lastChild] } }; function Dl(e, t, n) { const s = e._vtc; s && (t = (t ? [t, ...s] : [...s]).join(" ")), t == null ? e.removeAttribute("class") : n ? e.setAttribute("class", t) : e.className = t } function Sl(e, t, n) { const s = e.style, r = te(n); if (n && !r) { if (t && !te(t)) for (const o in t) n[o] == null && Fn(s, o, ""); for (const o in n) Fn(s, o, n[o]) } else { const o = s.display; r ? t !== n && (s.cssText = n) : t && e.removeAttribute("style"), "_vod" in e && (s.display = o) } } const As = /\s*!important$/; function Fn(e, t, n) { if ($(n)) n.forEach(s => Fn(e, t, s)); else if (n == null && (n = ""), t.startsWith("--")) e.setProperty(t, n); else { const s = kl(e, t); As.test(n) ? e.setProperty(pt(s), n.replace(As, ""), "important") : e[s] = n } } const Ms = ["Webkit", "Moz", "ms"], bn = {}; function kl(e, t) { const n = bn[t]; if (n) return n; let s = ut(t); if (s !== "filter" && s in e) return bn[t] = s; s = ks(s); for (let r = 0; r < Ms.length; r++) { const o = Ms[r] + s; if (o in e) return bn[t] = o } return t } const Ps = "http://www.w3.org/1999/xlink"; function Ul(e, t, n, s, r) { if (s && t.startsWith("xlink:")) n == null ? e.removeAttributeNS(Ps, t.slice(6, t.length)) : e.setAttributeNS(Ps, t, n); else { const o = Wr(t); n == null || o && !Us(n) ? e.removeAttribute(t) : e.setAttribute(t, o ? "" : n) } } function Kl(e, t, n, s, r, o, l) { if (t === "innerHTML" || t === "textContent") { s && l(s, r, o), e[t] = n ?? ""; return } const c = e.tagName; if (t === "value" && c !== "PROGRESS" && !c.includes("-")) { e._value = n; const a = c === "OPTION" ? e.getAttribute("value") : e.value, _ = n ?? ""; a !== _ && (e.value = _), n == null && e.removeAttribute(t); return } let u = !1; if (n === "" || n == null) { const a = typeof e[t]; a === "boolean" ? n = Us(n) : n == null && a === "string" ? (n = "", u = !0) : a === "number" && (n = 0, u = !0) } try { e[t] = n } catch { } u && e.removeAttribute(t) } function Wl(e, t, n, s) { e.addEventListener(t, n, s) } function zl(e, t, n, s) { e.removeEventListener(t, n, s) } function ql(e, t, n, s, r = null) { const o = e._vei || (e._vei = {}), l = o[t]; if (s && l) l.value = s; else { const [c, u] = Jl(t); if (s) { const a = o[t] = Ql(s, r); Wl(e, c, a, u) } else l && (zl(e, c, l, u), o[t] = void 0) } } const $s = /(?:Once|Passive|Capture)$/; function Jl(e) { let t; if ($s.test(e)) { t = {}; let s; for (; s = e.match($s);)e = e.slice(0, e.length - s[0].length), t[s[0].toLowerCase()] = !0 } return [e[2] === ":" ? e.slice(3) : pt(e.slice(2)), t] } let xn = 0; const Vl = Promise.resolve(), Zl = () => xn || (Vl.then(() => xn = 0), xn = Date.now()); function Ql(e, t) { const n = s => { if (!s._vts) s._vts = Date.now(); else if (s._vts <= n.attached) return; Ee(Yl(s, n.value), t, 5, [s]) }; return n.value = e, n.attached = Zl(), n } function Yl(e, t) { if ($(t)) { const n = e.stopImmediatePropagation; return e.stopImmediatePropagation = () => { n.call(e), e._stopped = !0 }, t.map(s => r => !r._stopped && s && s(r)) } else return t } const Rs = /^on[a-z]/, Xl = (e, t, n, s, r = !1, o, l, c, u) => { t === "class" ? Dl(e, s, r) : t === "style" ? Sl(e, n, s) : en(t) ? Ln(t) || ql(e, t, n, s, l) : (t[0] === "." ? (t = t.slice(1), !0) : t[0] === "^" ? (t = t.slice(1), !1) : Gl(e, t, s, r)) ? Kl(e, t, s, o, l, c, u) : (t === "true-value" ? e._trueValue = s : t === "false-value" && (e._falseValue = s), Ul(e, t, s, r)) }; function Gl(e, t, n, s) { return s ? !!(t === "innerHTML" || t === "textContent" || t in e && Rs.test(t) && N(n)) : t === "spellcheck" || t === "draggable" || t === "translate" || t === "form" || t === "list" && e.tagName === "INPUT" || t === "type" && e.tagName === "TEXTAREA" || Rs.test(t) && te(n) ? !1 : t in e } const ei = se({ patchProp: Xl }, jl); let Fs; function ti() { return Fs || (Fs = gl(ei)) } const ni = (...e) => { const t = ti().createApp(...e), { mount: n } = t; return t.mount = s => { const r = si(s); if (!r) return; const o = t._component; !N(o) && !o.render && !o.template && (o.template = r.innerHTML), r.innerHTML = ""; const l = n(r, !1, r instanceof SVGElement); return r instanceof Element && (r.removeAttribute("v-cloak"), r.setAttribute("data-v-app", "")), l }, t }; function si(e) { return te(e) ? document.querySelector(e) : e } const Ns = () => [ri, oi, li, ui, ci, ii, fi], ri = [[1], [1], [1], [1]], oi = [[0, 1], [0, 1], [1, 1]], li = [[1, 0], [1, 0], [1, 1]], ii = [[1, 1, 1], [0, 1, 0]], ci = [[0, 1, 1], [1, 1, 0]], fi = [[1, 1, 0], [0, 1, 1]], ui = [[1, 1], [1, 1]], ai = () => [di, hi, pi, _i, gi, mi, vi, bi, xi, wi, yi], di = [[1, 0, 1]], hi = [[1, 0], [0, 1]], pi = [[0, 0, 1], [0, 1, 0], [1, 0, 0]], _i = [[1, 0, 1], [1, 0, 1]], gi = [[0, 1, 0], [1, 1, 1], [0, 1, 0]], mi = [[1, 1, 1], [1, 0, 1]], vi = [[1, 1, 1], [1, 1, 1]], bi = [[1, 1, 1], [1, 1, 1], [1, 1, 1]], xi = [[1, 1, 1], [1, 0, 0], [1, 0, 0]], wi = [[1, 1, 1], [0, 1, 0], [0, 1, 0]], yi = [[1, 1], [1, 1], [1, 1], [1, 1]], Ei = () => [Ci, Oi, Ti, Ii], Ci = [[1]], Oi = [[1, 1]], Ti = [[1, 1, 1]], Ii = [[1, 1], [0, 1]], wn = e => { let t = new Array(e[0].length); for (let n = 0; n < e.length; n++)for (let s = 0; s < e[0].length; s++)t[s] || (t[s] = new Array(e.length)), t[s][e.length - 1 - n] = e[n][s]; return t }, Rt = (e, t, n, s, r) => { if (typeof n > "u") return []; let o = []; for (let l = 0; l < n.length; l++)for (let c = 0; c < n[0].length; c++)if (n[l][c]) { const u = []; u[0] = e + l, u[1] = t + c, o[o.length] = u } if (typeof s < "u" && e + n.length > s) if (e > 0) Rt(e - 1, t, n, s, r); else return []; if (typeof r < "u" && t + n[0].length > r) if (t > 0) Rt(e, t - 1, n, s, r); else return []; return o }, Ls = (e, t, n) => Rt(0, e, t, void 0, n), Bs = e => { const t = []; return e.forEach(n => { t.push(n[1]) }), t.sort(), [e[0][0], t[t.length - 1], e[e.length - 1][0], t[0]] }; let Wt = (e = 21) => crypto.getRandomValues(new Uint8Array(e)).reduce((t, n) => (n &= 63, n < 36 ? t += n.toString(36) : n < 62 ? t += (n - 26).toString(36).toUpperCase() : n > 62 ? t += "-" : t += "_", t), "");/*! Element Plus Icons Vue v2.1.0 */var Ge = (e, t) => { let n = e.__vccOpts || e; for (let [s, r] of t) n[s] = r; return n }, Ai = { name: "CaretBottom" }, Mi = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" }, Pi = L("path", { fill: "currentColor", d: "m192 384 320 384 320-384z" }, null, -1), $i = [Pi]; function Ri(e, t, n, s, r, o) { return re(), le("svg", Mi, $i) } var Fi = Ge(Ai, [["render", Ri], ["__file", "caret-bottom.vue"]]), Ni = { name: "CaretLeft" }, Li = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" }, Bi = L("path", { fill: "currentColor", d: "M672 192 288 511.936 672 832z" }, null, -1), Hi = [Bi]; function ji(e, t, n, s, r, o) { return re(), le("svg", Li, Hi) } var Di = Ge(Ni, [["render", ji], ["__file", "caret-left.vue"]]), Si = { name: "CaretRight" }, ki = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" }, Ui = L("path", { fill: "currentColor", d: "M384 192v640l384-320.064z" }, null, -1), Ki = [Ui]; function Wi(e, t, n, s, r, o) { return re(), le("svg", ki, Ki) } var zi = Ge(Si, [["render", Wi], ["__file", "caret-right.vue"]]), qi = { name: "CaretTop" }, Ji = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" }, Vi = L("path", { fill: "currentColor", d: "M512 320 192 704h639.936z" }, null, -1), Zi = [Vi]; function Qi(e, t, n, s, r, o) { return re(), le("svg", Ji, Zi) } var Yi = Ge(qi, [["render", Qi], ["__file", "caret-top.vue"]]), Xi = { name: "Cherry" }, Gi = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" }, ec = L("path", { fill: "currentColor", d: "M261.056 449.6c13.824-69.696 34.88-128.96 63.36-177.728 23.744-40.832 61.12-88.64 112.256-143.872H320a32 32 0 0 1 0-64h384a32 32 0 1 1 0 64H554.752c14.912 39.168 41.344 86.592 79.552 141.76 47.36 68.48 84.8 106.752 106.304 114.304a224 224 0 1 1-84.992 14.784c-22.656-22.912-47.04-53.76-73.92-92.608-38.848-56.128-67.008-105.792-84.352-149.312-55.296 58.24-94.528 107.52-117.76 147.2-23.168 39.744-41.088 88.768-53.568 147.072a224.064 224.064 0 1 1-64.96-1.6zM288 832a160 160 0 1 0 0-320 160 160 0 0 0 0 320zm448-64a160 160 0 1 0 0-320 160 160 0 0 0 0 320z" }, null, -1), tc = [ec]; function nc(e, t, n, s, r, o) { return re(), le("svg", Gi, tc) } var sc = Ge(Xi, [["render", nc], ["__file", "cherry.vue"]]), rc = { name: "Orange" }, oc = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" }, lc = L("path", { fill: "currentColor", d: "M544 894.72a382.336 382.336 0 0 0 215.936-89.472L577.024 622.272c-10.24 6.016-21.248 10.688-33.024 13.696v258.688zm261.248-134.784A382.336 382.336 0 0 0 894.656 544H635.968c-3.008 11.776-7.68 22.848-13.696 33.024l182.976 182.912zM894.656 480a382.336 382.336 0 0 0-89.408-215.936L622.272 446.976c6.016 10.24 10.688 21.248 13.696 33.024h258.688zm-134.72-261.248A382.336 382.336 0 0 0 544 129.344v258.688c11.776 3.008 22.848 7.68 33.024 13.696l182.912-182.976zM480 129.344a382.336 382.336 0 0 0-215.936 89.408l182.912 182.976c10.24-6.016 21.248-10.688 33.024-13.696V129.344zm-261.248 134.72A382.336 382.336 0 0 0 129.344 480h258.688c3.008-11.776 7.68-22.848 13.696-33.024L218.752 264.064zM129.344 544a382.336 382.336 0 0 0 89.408 215.936l182.976-182.912A127.232 127.232 0 0 1 388.032 544H129.344zm134.72 261.248A382.336 382.336 0 0 0 480 894.656V635.968a127.232 127.232 0 0 1-33.024-13.696L264.064 805.248zM512 960a448 448 0 1 1 0-896 448 448 0 0 1 0 896zm0-384a64 64 0 1 0 0-128 64 64 0 0 0 0 128z" }, null, -1), ic = [lc]; function cc(e, t, n, s, r, o) { return re(), le("svg", oc, ic) } var fc = Ge(rc, [["render", cc], ["__file", "orange.vue"]]), uc = { name: "Rank" }, ac = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" }, dc = L("path", { fill: "currentColor", d: "m186.496 544 41.408 41.344a32 32 0 1 1-45.248 45.312l-96-96a32 32 0 0 1 0-45.312l96-96a32 32 0 1 1 45.248 45.312L186.496 480h290.816V186.432l-41.472 41.472a32 32 0 1 1-45.248-45.184l96-96.128a32 32 0 0 1 45.312 0l96 96.064a32 32 0 0 1-45.248 45.184l-41.344-41.28V480H832l-41.344-41.344a32 32 0 0 1 45.248-45.312l96 96a32 32 0 0 1 0 45.312l-96 96a32 32 0 0 1-45.248-45.312L832 544H541.312v293.44l41.344-41.28a32 32 0 1 1 45.248 45.248l-96 96a32 32 0 0 1-45.312 0l-96-96a32 32 0 1 1 45.312-45.248l41.408 41.408V544H186.496z" }, null, -1), hc = [dc]; function pc(e, t, n, s, r, o) { return re(), le("svg", ac, hc) } var _c = Ge(uc, [["render", pc], ["__file", "rank.vue"]]); const G = { TOP: "top", LEFT: "left", RIGHT: "right", DOWN: "down", ROTATE: "rotate", MOMENT: "moment" }, rt = ["#ff514d", "#ffa700", "#ffd601", "#5fc61d", "#1acdca", "#34b7fd", "#be54ff"], bt = [[10, 15], [10, 20], [12, 18], [16, 24], [20, 30]], $r = e => (No("data-v-fd53aff6"), e = e(), Lo(), e), gc = { id: "play_window" }, mc = { id: "fun_area" }, vc = { id: "score_box" }, bc = { id: "score_out", class: "out" }, xc = { id: "score" }, wc = { id: "max_score_out", class: "out" }, yc = { id: "max_score" }, Ec = { id: "btns_out", class: "out" }, Cc = { id: "btns" }, Oc = { id: "block_box" }, Tc = ["id"], Ic = { id: "play_info" }, Ac = { id: "preview_out", class: "out" }, Mc = { id: "preview" }, Pc = ["id"], $c = { id: "setting_out", class: "out" }, Rc = { id: "setting" }, Fc = $r(() => L("input", { id: "special", type: "checkbox" }, null, -1)), Nc = $r(() => L("input", { id: "few", type: "checkbox" }, null, -1)), Lc = hr({ __name: "Index", setup(e) { const t = qe(10), n = qe(15), s = Pr(() => `${90 / n.value}vh`), r = qe([t.value, n.value]), o = qe(), l = qe(); let c = [...Ns()], u, a = [], _, b, C, M = 1300, K = 0; const F = qe(0), V = qe(0); let S = { max: 0, board: 0, special: !1, few: !1 }; gr(() => { R(o, n.value, t.value), R(l, 4, 8), window.addEventListener("keydown", et), window.addEventListener("keydown", Pe), ee() }); const ee = () => { const E = localStorage.getItem("gameConfig"); E && (S = { ...JSON.parse(E) }), V.value = S.max, t.value = bt[S.board][0], n.value = bt[S.board][1], r.value[0] = t.value, r.value[1] = n.value, R(o, n.value, t.value), c = [...Ns()], S.special && (c.push(...ai()), document.getElementById("special").checked = !0), S.few && (c.push(...Ei()), document.getElementById("few").checked = !0), Ce(Be()) }, Q = (E, w, O) => { S[E] = w, O && O(), localStorage.setItem("gameConfig", JSON.stringify(S)) }, R = (E, w, O, k) => { E.value = new Array(w); for (let j = 0; j < E.value.length; j++) { E.value[j] = new Array(O); for (let z = 0; z < E.value[j].length; z++)E.value[j][z] = {}, E.value[j][z].id = Wt(), E.value[j][z].state = 0, E.value[j][z].color = k || "#ddd" } }, pe = (E, w) => { E.value.forEach(O => { O.forEach(k => { k.state = 0, w && (k.color = w) }) }) }, Le = (E, w) => { C && clearInterval(C), E && (C = setInterval(() => { Y(G.DOWN) }, M)), M > 600 && (M -= typeof w == "number" ? w : 10) }, Be = () => { a.push(Math.floor(Math.random() * c.length)); let E = a[0]; return a.length < 3 ? Be() : E = a.shift(), E ? u = E : u = 0, c[E || 0] }, Ce = E => { Le(!0); let w = !1; _ = Ls(4, E), _.forEach(O => { o.value[O[0]][O[1]].color = rt[u % rt.length], o.value[O[0]][O[1]].state && (w = !0) }), pe(l, "#ddd"), a.forEach((O, k) => { Ls(k * 4, c[O]).forEach(j => { l.value[j[0]][j[1]].color = rt[O % rt.length] }) }), w && Ft(), b = [], E.forEach(O => { b[b.length] = [...O] }) }, ze = E => { const w = $e => { O.forEach(me => { me[0] += $e[0], me[1] += $e[1] }) }; let O = []; _.forEach($e => { O[O.length] = [...$e] }); const [k, j, z, oe] = Bs(O); switch (E) { case G.LEFT: if (oe == 0) return; w([0, -1]); break; case G.RIGHT: if (j == o.value[0].length - 1) return; w([0, 1]); break; case G.DOWN: if (z == o.value.length - 1) return; w([1, 0]); break; case G.ROTATE: z - k > j - oe && oe + z - k > t.value - 1 ? O = Rt(k, k - z + t.value - 1, wn(b)) : O = Rt(k, oe, wn(b)), b = wn(b); break; case G.MOMENT: for (; ze(G.DOWN);)Y(G.DOWN), w([1, 0]); K = 2; break; default: return }let Nt = !0; if (O.forEach($e => { o.value[$e[0]][$e[1]].state == 1 && (Nt = !1) }), Nt) return O }, Y = E => { const w = ze(E); if (typeof w == "object" && (_.forEach(O => { o.value[O[0]][O[1]].color = "#ddd" }), w.forEach(O => { o.value[O[0]][O[1]].color = rt[u % rt.length] }), _ = w), !ze(G.DOWN) && (K < 2 && E == G.DOWN && K++, K >= 2)) { _.forEach(j => { o.value[j[0]][j[1]].state = 1 }); const O = Bs(_); let k = 0; for (let j = O[0]; j <= O[2]; j++) { let z = !0; if (o.value[j].forEach(oe => { oe.state == 0 && (z = !1) }), z) { o.value.splice(j, 1), o.value.unshift(new Array(t.value)); for (let oe = 0; oe < o.value[j].length; oe++)o.value[0][oe] = {}, o.value[0][oe].id = Wt(), o.value[0][oe].state = 0, o.value[0][oe].color = "#ddd"; k++ } } F.value += k * (1 + k) * 5 * t.value, F.value > V.value && (Q("max", F.value), V.value = F.value), Ce(Be()), K = 0 } }, Pe = E => { switch (E.key) { case "ArrowLeft": Y(G.LEFT); break; case "ArrowRight": Y(G.RIGHT); break; case "ArrowDown": Y(G.DOWN); break; case "ArrowUp": Y(G.ROTATE); break; case " ": Y(G.MOMENT); break; default: return }E.preventDefault() }; let He = !1; const et = E => { switch (E.key) { case "r": case "R": ne(); break; case "p": case "P": je(He); break; default: return }E.preventDefault() }, je = E => { Le(E, 0), E ? window.addEventListener("keydown", Pe) : window.removeEventListener("keydown", Pe); const w = document.getElementsByClassName("pk"); for (let O = 0; O < w.length; O++)w[O].disabled = !E; He = !E }, Ft = () => { je(!1), pe(o) }, ne = () => { _ = [], b = [], K = 0, M = 1300, pe(o, "#ddd"), pe(l, "#ddd"), ee(), je(!0) }; return (E, w) => (re(), le("div", gc, [L("div", mc, [L("div", vc, [L("div", bc, [L("div", xc, Bt(F.value), 1)]), L("div", wc, [L("div", yc, Bt(V.value), 1)])]), L("div", Ec, [L("div", Cc, [L("button", { class: "role", onClick: w[0] || (w[0] = O => ne()) }, "重开(R)"), L("button", { class: "direction pk", onClick: w[1] || (w[1] = O => Y(q(G).ROTATE)) }, [Se(" 旋转 "), ae(q(Yi), { class: "dir_logo" })]), L("button", { class: "role", onClick: w[2] || (w[2] = O => je(q(He))) }, "暂停(P)"), L("button", { class: "direction pk", onClick: w[3] || (w[3] = O => Y(q(G).LEFT)) }, [Se(" 左移 "), ae(q(Di), { class: "dir_logo" })]), L("button", { class: "direction pk", onClick: w[4] || (w[4] = O => Y(q(G).DOWN)) }, [Se(" 下移 "), ae(q(Fi), { class: "dir_logo" })]), L("button", { class: "direction pk", onClick: w[5] || (w[5] = O => Y(q(G).RIGHT)) }, [Se(" 右移 "), ae(q(zi), { class: "dir_logo" })]), L("button", { class: "role pk", id: "space", onClick: w[6] || (w[6] = O => Y(q(G).MOMENT)) }, "瞬落(空格)")])])]), L("div", Oc, [(re(!0), le(ge, null, Kt(o.value, O => (re(), le("div", { class: "block_line", key: q(Wt)() }, [(re(!0), le(ge, null, Kt(O, k => (re(), le("div", { class: "block", key: k.id, id: k.id, style: Ot(`width:${s.value};height:${s.value};background-color:${k.color}`) }, null, 12, Tc))), 128))]))), 128))]), L("div", Ic, [L("div", Ac, [L("div", Mc, [(re(!0), le(ge, null, Kt(l.value, O => (re(), le("div", { class: "block_line", key: q(Wt)() }, [(re(!0), le(ge, null, Kt(O, k => (re(), le("div", { class: "block", key: k.id, id: k.id, style: Ot(`width:${s.value};height:${s.value};max-width:35px;max-height:35px;background-color:${k.color}`) }, null, 12, Pc))), 128))]))), 128))])]), L("div", $c, [L("div", Rc, [L("label", null, [L("div", { id: "board_size", onClick: w[7] || (w[7] = O => Q("board", ++q(S).board % q(bt).length, () => { r.value[0] = q(bt)[q(S).board][0], r.value[1] = q(bt)[q(S).board][1] })) }, [ae(q(_c)), Se(" " + Bt(r.value[0]) + " × " + Bt(r.value[1]), 1)])]), L("label", null, [Fc, L("div", { onClick: w[8] || (w[8] = O => Q("special", !q(S).special)) }, [ae(q(fc)), Se("趣味方块 ")])]), L("label", null, [Nc, L("div", { onClick: w[9] || (w[9] = O => Q("few", !q(S).few)) }, [ae(q(sc)), Se("减数方块 ")])])])])])])) } }); const Bc = (e, t) => { const n = e.__vccOpts || e; for (const [s, r] of t) n[s] = r; return n }, Hc = Bc(Lc, [["__scopeId", "data-v-fd53aff6"]]), jc = hr({ __name: "App", setup(e) { return (t, n) => (re(), wl(Hc)) } }); ni(jc).mount("#app");
  </script>
</body>

</html>